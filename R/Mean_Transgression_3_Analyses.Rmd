---
title: "Transgressive segregation in mean phenotype"
author: "Keisuke Atsumi"
date: '`r format(Sys.time(), "%y/%m/%d %H:%M")`'
output:
  html_document:
    code_folding: hide
    theme: united
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}

rm(list=ls())  # reset workspace
sessionInfo()  # show R version etc
options(scipen=100)  # do not show numbers using exponential

# install & load packages
pacman::p_load(
  openxlsx,   # open excel
  tidyverse,  
  kableExtra,
  pander,     # nice tables
  MCMCglmm,   # glmm
  knitr,      # rmarkdown
  magrittr,   # Extend pipe
  ape,        # Phylogeny
  phytools,   # Phylogeny
  svglite,    # Export SVG plots
  ggiraphExtra, # Geom predict
  patchwork   # combine multiple plots
)
opts_chunk$set(prompt=TRUE, message=FALSE, comment="", warning = FALSE) 
options(knitr.kable.NA = '') # Hide NAs in kable table

### Correcting estimate of binomial regression###
c2 <- (16 * sqrt(3)/(15 * pi))^2

```

# Exploring frequency of transgressive segregation and it affecting factors

```{r TS}

dat.full <- read.csv("../data/mean.ES.TS.csv", head = TRUE) %>%
  # Assign overdoinance to 1, no TS to 0 for each effect size
  mutate(TS = ifelse(lnRR.es < 0, 1, 0)) %>%
  ### Join with metadata ###
  left_join(
    .,
    read.xlsx(
      "../data/original.data.xlsx", sheet = "Metadata"
      )
    ) %>%
  mutate_at(vars(divergence.cytb:surv.relat.hyb21), as.numeric) %>%
  mutate_at(
    vars(contains("divergence"), contains("surv.relat")), scale
    ) %>%
  as.data.frame %>%
  select(-trait) %>%
  mutate_at("taxa", as.factor) %>%
  within(levels(TS) <- c("No", "Transgressive segregation")) %>%
  within(
    taxa <- ordered(
      taxa,
      levels = c("Neuroptera", "Coleoptera", "Diptera", "Lepidoptera", "Orthoptera", "Aves", "Rodentia", "Anura", "Cichliformes")
      )
    ) %>%
  drop_na(hetero.sex, pheno.div.diff, trait.type, divergence.COI) %>%
  # Insect or no
  mutate(
    insect = ifelse(taxa %in% c("Aves", "Rodentia", "Anura", "Cichliformes"), "no", "insect"),
  )


#### Phylogenetic tree for mcmcglmm ####

# compute branch lengths of tree
phylo_branch <- read.tree(file = "../data/phylo.mean.TS.tre") %>%
  compute.brlen(bin.tree, method = "Grafen", power = 1)

# saving phylogeneic matrix
phylo_cor <- vcv(phylo_branch, cor = T)

# generating inverse phylogenetic matrix for MCMCglmm
# Note one of the tips is called "Lates calcarifer (estimated)"
phylo_branch$node.label <- NULL
phylo_MCMC <- MCMCglmm::inverseA(phylo_branch, nodes = "ALL", scale = TRUE)$Ainv

```

# Frequency of TS
How frequent the TS is?  

```{r freq of transgression}

# TS.ES <- TS %>% filter(TS == "1") %>% 
#   distinct(ES.ID)
# noTS <- TS %>%
#   filter(!ES.ID %in% TS.ES$ES.ID) %>%
#   distinct(ES.ID, .keep_all = TRUE)

### N of TS in each taxa and each direction ###
summary <- bind_rows(
  # All observations
  dat.full %>%
    group_by(taxa) %>%
    summarise(
      'Species pair' = length(unique(species.pair)),
      Observations = length(unique(ES.ID)),
      Study = length(unique(Study.ID))
      ) %>%
    mutate(direction = "All Observations")
  ,
  # TS for any direction
  dat.full %>%
    filter(TS == "1") %>%
    group_by(taxa) %>%
    summarise(
      'Species pair' = length(unique(species.pair)),
      Observations = length(unique(ES.ID)),
      Study = length(unique(Study.ID))
      ) %>%
    mutate(direction = "Any directions")
  ,
  # TS for each direction
  dat.full %>%
    filter(TS == "1") %>%
    group_by(taxa, direction) %>%
    summarise(
      'Species pair' = length(unique(species.pair)),
      Observations = length(unique(ES.ID)),
      Study = length(unique(Study.ID))
      )
  ) %>%
  # Assign 0 for no observation of TS
  replace(., is.na(.), "0") %>% 
  # Make tidy data
  gather(key = metrics, value = N, -c(taxa, direction)) %>%
  # Order factors
  mutate_at(vars("metrics", "direction"), as.factor) %>%
  # Order taxon
  within(
    metrics <- ordered(
      metrics,
      levels = c("Study", "Species pair", "Observations")
      )
  ) %>%
  # Order TS category
  within(
    direction <- ordered(
      direction,
      levels = c("All Observations", "Any directions", "+", "-")
      )
    ) %>%
  # Change names of TS category to more intuitive name
  within(
    levels(direction) <- c("All Obser- vations", "All trans- gression", "Larger mean", "Smaller mean")
      ) %>%
  filter(metrics != "Study")

### Plot ###
plot <- ggplot(summary, aes(x = "", y = N, fill = taxa)) +
  geom_bar(width = 1, stat = "identity") +
  scale_fill_brewer() +
  facet_grid(
    scale = "free", metrics ~ direction,
    # strip text into two lines
    labeller = label_wrap_gen(width = 13)
    ) +
  xlab("") +
  theme_bw() +
  theme(
    strip.text = element_text(size = 14),
    axis.text.y = element_text(size = 14),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(), 
  )
plot

ggsave(
  plot = plot +
    theme(legend.position = "none"), 
  file = "../Analysis/mean.TS.frequency.svg", height = 3.6, width = 5.1
  )

### Total number of observations and percentage ###
summary %>%
  group_by(direction, metrics) %>%
  # Count number of observaitons and species pairs
  summarise(sum(N)) %>%
  spread(key = metrics, value = "sum(N)") %>%
  as.data.frame() %>%
  # Calculate percentage
  mutate(
    percent.species.pair = .[, "Species pair"]/.[1, "Species pair"]*100,
    percent.observations = Observations/.[1, "Observations"]*100
  ) %>%
  mutate_at(vars(contains("percent")), round, 2) %>%
  kable("html", digits = 3) %>% kable_styling("striped", position = "left")


```

# Seeking factor influences the frequency of TS
Previous study (Stelkens et al 2009 Evolution) showed TS in F1 become frequent as parental species diverges in plant. How about male sexual traits in animals?  
Does TS biased toward larger phenotypic value? -> <i>parentalspS</i> will negative   
Does TS biased toward father species? -> <i>patmatmother</i> will negative



```{r mixed model}

for (k in c("alltaxon", "insect")) {
  
  if (k == "alltaxon") {
    dat <- dat.full
  } else {
    dat <- dat.full %>% 
      filter(insect == k)
  }

  # ### Setting prior to logistic regression ###
  # prior <- list(
  #   B=list(
  #     mu = rep(0, 17), # N of coefficient. (level -1) for categorical factors, 1 for continuous factors, 1 for intercept
  #     V = gelman.prior(~
  #       parental*hetero.sex +
  #       parental*direction +
  #       direction*divergence.COI + direction*pheno.div.ratio +
  #       direction*hetero.sex +
  #       direction*trait.type +
  #       direction*distribution + direction*reciprocal,
  #     data = dat, # formula and data
  #     scale=sqrt(pi^2/3+1))), # error distribution of logistic regression
  #   R=list(V=1,fix=1),
  #   G = list(
  #     G1 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
  #     G2 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
  #     G3 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
  #     G4 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000)
  #     )
  #   )
  # ## Phylogenetic binomial regression ###
  # phylmix <-MCMCglmm(
  #   fixed = TS ~
  #     parental*hetero.sex + parental*direction +
  #     direction*divergence.COI + direction*pheno.div.ratio +
  #     direction*hetero.sex + direction*trait.type +
  #     direction*distribution + direction*reciprocal,
  #   # idh(SE):units | weight by SE of effect size
  #   random = ~ Study.ID + Cross.ID + spL.name + idh(SE):units,
  #   family = "categorical",
  #   verbose = FALSE,
  #   ginverse = list(spL.name = phylo_MCMC),
  #   prior = prior,
  #   data = dat,
  #   nitt = 60000,  # Increase the number of iterations, default is 13000
  #   burnin = 5000  # Increase the number of burnin, default is 3000
  # )
  # phylmix$Sol <- phylmix$Sol/sqrt(1+c2)
  # ### Save model ###
  # saveRDS(phylmix, file = paste("../Analysis/Mean.transgression.allfactors", k, "obj", sep = "."))


### Load model ###
phylmix <- readRDS(paste("../Analysis/Mean.transgression.allfactors", k, "obj", sep = "."))

sum <- left_join(
  # corrected estimates & SD
  summary(phylmix$Sol)$statistics %>%
    as.data.frame() %>%
    rownames_to_column(var = "factors"),
  # P
  summary(phylmix)$solutions %>%
  as.data.frame() %>%
    rownames_to_column(var = "factors"),
  by = "factors"
  ) %>%
  mutate(significance = ifelse(pMCMC < 0.05, "*", "")) %>%
  ### Grouping factors ###
    mutate(
      group = 
        ifelse(str_detect(factors, "direction.:"), 
               "increasing variation",
               ifelse(str_detect(factors, "parentalMother:"),
                      "polar overdominance",
                      ifelse(factors == "hetero.sexMale:direction+",
                             "increasing variation",
                             "transgressive segregation"
                             )
                      )
               )
    ) %>%
    mutate_at("group", as.factor) %>%
    within(group <- ordered(group, c("transgressive segregation", "increasing variation", "polar overdominance"))) %>%
    ### Change factor names ###
    within(
      factors <- str_remove_all(
        factors, "direction.:"
        ) %>%
        str_remove_all(., "parentalMother:") %>%
        str_remove_all(., ":direction.")
      ) %>%
    within(
      factors <- factor(
        factors, ordered = TRUE, 
        levels = c("trait.typesound", "hetero.sexMale", "parentalMother", "reciprocalViable", "distributionOverlap", "pheno.div.ratio",  "divergence.COI",  "direction+", "(Intercept)")
        )
      )

### Plot ###
metaplot <- ggplot(sum, aes(
  x = post.mean, 
  # Inverse order of factors
  y = factors
  )) +
  # Vertical line
  geom_vline(
    xintercept = 0, size = 0.3, 
    colour = "grey30", linetype = "dotted"         
    ) +
  # CI
  geom_errorbarh(
    aes(
      xmin = sum[, 'l-95% CI'], xmax = sum[, 'u-95% CI'],
      colour=significance 
      ), 
    height = .0001
    ) +
  # Color of plots and errorbars
  scale_colour_manual(values = c("grey60", "black")) +
  geom_point(size = 1.5, aes(colour = significance)) +
  scale_fill_manual(values = c("grey60", "black")) +
  # Title
  ggtitle(k) +
  ylab("") + xlab("estimate with CI") +
  # Combine different plots for main factors and interactions
  facet_grid(group~., scales = "free", space = "free") +
  # Themes
  theme_bw() +
  theme(
    panel.grid = element_blank(),
    legend.position = "none",
    panel.border=element_blank(),
    axis.text.x = element_text(size = 11),
    axis.text.y = element_text(size = 12),
    axis.line=element_line(colour = "grey70")
    )
print(metaplot)

  ggsave(
      plot = metaplot, 
      file = paste("../Analysis/mean.TS.result", k, "svg", sep = "."), 
      height = 6.75, width = 4.6
      )

### Output result ###


  sum %>% 
    select(group, factors, Mean, SD, pMCMC, significance) %>%
    mutate_at(c("Mean", "SD"), round, 2) %>%
    mutate_at(c("pMCMC"), round, 3) %>%
    print()

  # transformation for estimate
  # summary(phylmix$Sol/sqrt(1+c2))
  # transformation for varaince
  summary(phylmix$VCV/(1+c2)) %>% 
    print()

}
```



```{r continuous factors plot}

# +++++++++++++++++++++++++++++++++++++++++++#
# To set raw metadata in X axis, reload raw metadata and combine to transgression dataset
# +++++++++++++++++++++++++++++++++++++++++++#
rawdat <- dat.full %>%
  select(-pheno.div.ratio, -divergence.COI) %>%
  # lnRR between parental species as phenotypic distance
  mutate(pheno.div.ratio = log(Mn.spL/Mn.spS)) %>%
  left_join(
    .,
    read.xlsx("../data/original.data.xlsx", sheet = "Metadata") %>%
      select(Cross.ID, divergence.COI)
    ) %>%
  # Natural log of genetic distance
  mutate_at("divergence.COI", log)

# +++++++++++++++++++++++++++++++++++++++++++#
# To draw regression line separatory in transgression for larger mean and smaller mean, create two dataset
# +++++++++++++++++++++++++++++++++++++++++++#
# Dataset including non TS & TS for larger mean
dat.TS.larger <- filter(rawdat, direction == "+")
# Dataset including non TS & TS for smaller mean
dat.TS.smaller <- filter(rawdat, direction == "-")

# +++++++++++++++++++++++++++++++++++++++++++#
# Genetic distance
# +++++++++++++++++++++++++++++++++++++++++++#

for (i in c("divergence.COI", "pheno.div.ratio")) {
  
  # Transgression for larger mean
  reg.larger <- glm(
    TS ~ dat.TS.larger[, i], 
    data = dat.TS.larger, family = binomial
    )$coefficients %>%
    as.vector
  # Transgression for smaller mean
  reg.smaller <- glm(
    TS ~ dat.TS.smaller[, i], 
    data = dat.TS.smaller, family = binomial
    )$coefficients %>%
    as.vector

  plot <- ggplot(rawdat, aes(x = rawdat[,i], y = rawdat[, "TS"])) +
      geom_jitter(height = 0.1, width = 0, aes(color = direction), alpha = 0.3) +
      # Transgression for larger mean
      stat_function(
        aes(color = "+"),
        fun = function(x) 
          1/(1 + exp(-(reg.larger[1] + x*reg.larger[2])))
        ) +
      # Transgression for smaller mean
      stat_function(
        aes(color = "-"),
        fun = function(x) 
          1/(1 + exp(-(reg.smaller[1] + x*reg.smaller[2])))
        ) +
      ylab("") + xlab("") +
      scale_color_manual(values = c("#FE6100", "#648FFF")) + 
      scale_y_continuous(breaks=seq(0,1)) +
      theme_bw() +
      theme(
        legend.position = "none",
        panel.grid.major.y = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text = element_text(size = 13),
        axis.title  = element_text(size = 15)
        )
  assign(paste("plot", i, sep = "."), plot)

}

plot.divergence.COI
plot.pheno.div.ratio


plot.divergence.COI + plot.pheno.div.ratio +
  plot_layout(ncol = 1)




# fit = glm(
#   TS ~ divergence.COI*direction,
#   data = rawdat,
#   family = binomial
#   )
# ggPredict(fit, se = TRUE, interactive = TRUE, digits = 3)

```



```{r Direct test for the significant categorical factors, results='asis'}

for (i in c("reciprocal", "trait.type")) {
  for (k in c("alltaxon", "insect")) {

    if (k == "alltaxon") {
      dat <- dat.full
    } else {
      dat <- dat.full %>% 
        filter(insect == k)
    }

    # Make new categorical data combining direction of TS and target categorical factor
    dat %<>%
      mutate(interaction = str_c(direction, .[, i], sep = "_"))
    
    
    # ### Setting prior to logistic regression ###
    # prior <- list(
    #   B=list(
    #     mu = rep(0, 4), # N of coefficient. (level -1) for categorical factors, 1 for continuous factors, 1 for intercept
    #     V = gelman.prior(~ interaction, # + trait.direction
    #     data = dat, # formula and data
    #     scale=sqrt(pi^2/3+1))), # error distribution of logistic regression
    #   R=list(V=1,fix=1),
    #   # Replicating same G for the number of random effects (here, 4)
    #   G = list(
    #     G1 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
    #     G2 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
    #     G3 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
    #     G4 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000)
    #     )
    #   )
    # 
    # phylmix <-MCMCglmm(
    #   fixed = TS ~  interaction -1, # + trait.direction
    #   family = "categorical",
    #   # idh(SE):units | weight by SE of effect size
    #   random = ~ Study.ID + Cross.ID + spL.name + idh(SE):units,
    #   verbose = FALSE,
    #   ginverse = list(spL.name = phylo_MCMC),
    #   prior = prior,
    #   data = dat
    # )
    # # Correct model result
    # phylmix$Sol <- phylmix$Sol/sqrt(1+c2)
    # ### Save model ###
    # saveRDS(
    #   phylmix,
    #   file =
    #     paste("../Analysis/Mean.transgression", i,k, "obj", sep = ".")
    #     )
  
  
  
    ### Load model ###
    phylmix <- readRDS(
      paste("../Analysis/Mean.transgression", i,k, "obj", sep = ".")
      )
  
    sum <- left_join(
      # corrected estimates & SD
      summary(phylmix$Sol)$statistics %>%
        as.data.frame() %>%
        rownames_to_column(var = "factors"),
      # P
      summary(phylmix)$solutions %>%
      as.data.frame() %>%
      rownames_to_column(var = "factors"),
      by = "factors"
      ) %>%
      mutate(
        significance = ifelse(pMCMC < 0.05, "*", ""),
        direction =
          ifelse(str_detect(factors, "\\+"), "Increase trait value",
                 ifelse(str_detect(factors, "\\-"), "Reduce trait value",
                        ifelse(str_detect(factors, "Father_"), "Exceed father trait value", "Exceed mother trait value")
                        )
                 )
        )
  
    ### Plot ###
    categoricalplot <- ggplot(
      sum, aes(x = post.mean, y = factors)
      ) +
      # Vertical line
      geom_vline(
        xintercept = 0, size = 0.3,
        colour = "grey30", linetype = "dotted"
        ) +
      # CI
      geom_errorbarh(
        aes(
          xmin = sum[, 'l-95% CI'],
          xmax = sum[, 'u-95% CI'],
          ),
        height = .0001
        ) +
      geom_point(size = 1.5, shape = 17) +
      # Title
      ylab("") + xlab("estimate with CI") +
      ggtitle(k) +
      # Combine different plots for main factors and interactions
      # Themes
      theme_bw() +
      # Combine different plots for main factors and interactions
      facet_grid(
        direction ~., scales = "free", drop = TRUE,
        labeller = label_wrap_gen(width = 13)
        ) +
      theme(
        panel.grid = element_blank(),
        legend.position = "none",
        panel.border = element_blank(),
        axis.text.x = element_text(size = 11),
        axis.text.y = element_text(size = 12),
        axis.line=element_line(colour = "grey70")
        )
    print(categoricalplot)
  
    ggsave(
        plot = categoricalplot,
        file =
            paste("../Analysis/Mean.TS.categorical", i,k, "svg", sep = "."),
        height = 6, width = 5
        )
    
  #####################################
  # Contrast
  #####################################
  
  bind_rows(
    HPDinterval(phylmix$Sol[,1] - phylmix$Sol[,2]) %>%
      as.data.frame() %>%
      mutate(
        from = row.names(summary(phylmix)$solutions)[1],
        to = row.names(summary(phylmix)$solutions)[2]
        ),
    HPDinterval(phylmix$Sol[,1] - phylmix$Sol[,3]) %>%
      as.data.frame() %>%
      mutate(
        from = row.names(summary(phylmix)$solutions)[1],
        to = row.names(summary(phylmix)$solutions)[3]
        ),
    HPDinterval(phylmix$Sol[,1] - phylmix$Sol[,4]) %>%
      as.data.frame() %>%
      mutate(
        from = row.names(summary(phylmix)$solutions)[1],
        to = row.names(summary(phylmix)$solutions)[4]
        ),
    HPDinterval(phylmix$Sol[,2] - phylmix$Sol[,3]) %>%
      as.data.frame() %>%
      mutate(
        from = row.names(summary(phylmix)$solutions)[2],
        to = row.names(summary(phylmix)$solutions)[3]
        ),
    HPDinterval(phylmix$Sol[,2] - phylmix$Sol[,4]) %>%
      as.data.frame() %>%
      mutate(
        from = row.names(summary(phylmix)$solutions)[2],
        to = row.names(summary(phylmix)$solutions)[4]
        ),
    HPDinterval(phylmix$Sol[,3] - phylmix$Sol[,4]) %>%
      as.data.frame() %>%
      mutate(
        from = row.names(summary(phylmix)$solutions)[3],
        to = row.names(summary(phylmix)$solutions)[4]
        )
    ) %>%
    as.data.frame() %>%
    mutate(
      sign = ifelse((upper < 0), "-", ifelse(lower > 0, "+", ""))
      ) %>%
    mutate_at(
      vars("from", "to"), 
      funs(
        str_replace_all(., pattern = "interaction", replacement = "direction")
        )
      ) %>%
    select(from, to, upper, lower, sign) %>%
    kable("html", digits = 3) %>% 
    kable_styling("striped", position = "left") %>%
    print()
    
  }
}

```

```{r trash, include = FALSE}

  # # Make new categorical data combining direction of TS and target categorical factor
  # if (i == "hetero.sex") {
  #   TS %<>%
  #     mutate(interaction = str_c(parental, .[, i], sep = "_"))
  # } else {
  #   TS %<>%
  #     mutate(interaction = str_c(direction, .[, i], sep = "_"))
  # }


```
