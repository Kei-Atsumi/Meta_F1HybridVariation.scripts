---
title: "Transgressive segregation in mean phenotype"
author: "Keisuke Atsumi"
date: '`r format(Sys.time(), "%y/%m/%d %H:%M")`'
output:
  html_document:
    code_folding: hide
    theme: united
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}

rm(list=ls())  # reset workspace
sessionInfo()  # show R version etc
options(scipen=100)  # do not show numbers using exponential

# install & load packages
pacman::p_load(
  openxlsx,   # open excel
  tidyverse,  
  kableExtra,
  pander,     # nice tables
  MCMCglmm,   # glmm
  metafor,    # meta analysis
  knitr,      # rmarkdown
  magrittr,   # Extend pipe
  rotl,       # Create phylogeny from Open Tree of Life
  ape,        # Phylogeny
  phytools,   # Phylogeny
  svglite,    # Export SVG plots
  ggiraphExtra, # Geom predict
  patchwork   # combine multiple plots
)
opts_chunk$set(prompt=TRUE, message=FALSE, comment="", warning = FALSE) 
options(knitr.kable.NA = '') # Hide NAs in kable table

### Correcting estimate of binomial regression###
c2 <- (16 * sqrt(3)/(15 * pi))^2

### Setting plot theme ###
foresttheme <- theme_bw() +
  theme(
    legend.position = "none",
    axis.line = element_line(size = 0.4, color = "grey50"),
    axis.ticks = element_line(size = 0.3, color = "grey50"),
    axis.text = element_text(size = 9.5, color = "black"),
    panel.grid.major.y = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    strip.text = element_text(size = 9.5, color = "black")
    )

```

```{r lnRR between hybrids and parental species}

# load spLS files
dat <- read.csv("../data/dat.mean.csv", head = TRUE)

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++#
# Difference between larger species (spL) and hybrids 
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++#

for (i in c("spL")) { # identify type of hybrids
  for (h in c("hybLS", "hybSL")) { # identify type of parentals
    assign(
      paste(h, i, sep = "_"),
        ### lnRR ###
        escalc(
          measure = "ROM",
          # N of hybrids
          n1i = dat[, paste("N", i, sep = ".")],
          # N of parentals
          n2i = dat[, paste("N", h, sep = ".")],
          # Mean of hybrids
          m1i = dat[, paste("Mn", i, sep = ".")],
          # Mean of parentals
          m2i = dat[, paste("Mn", h, sep = ".")],
          # SD of hybrids
          sd1i = dat[, paste("SD", i, sep = ".")],
          # SD of parentals
          sd2i = dat[, paste("SD", h, sep = ".")],
          data = dat
          ) %>%
        rename(lnRR.es = yi, lnRR.sv = vi) %>%
        select(ES.ID, contains("lnRR")) %>%
        mutate(
          # direction of transgressve segregation - greater than parent
          direction = "+",
          # SE for logistic distribution, for the weighted binomial regression
          # SE = pi/sqrt(3*(n_e + n_c))
          SE = pi/sqrt(3*(
            dat[, paste("N", i, sep = ".")] + dat[, paste("N", h, sep = ".")]
          ))
        )
    )
  }
}

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++#
# Difference between hybrids and smaller species (spS)
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++#

for (i in c("hybLS", "hybSL")) { # identify type of hybrids
  for (h in c("spS")) { # identify type of parentals
    assign(
      paste(i, h, sep = "_"),
        ### lnRR ###
        escalc(
          measure = "ROM",
          # N of hybrids
          n1i = dat[, paste("N", i, sep = ".")],
          # N of parentals
          n2i = dat[, paste("N", h, sep = ".")],
          # Mean of hybrids
          m1i = dat[, paste("Mn", i, sep = ".")],
          # Mean of parentals
          m2i = dat[, paste("Mn", h, sep = ".")],
          # SD of hybrids
          sd1i = dat[, paste("SD", i, sep = ".")],
          # SD of parentals
          sd2i = dat[, paste("SD", h, sep = ".")],
          data = dat
          ) %>%
          rename(lnRR.es = yi, lnRR.sv = vi) %>%
        select(ES.ID, contains("lnRR")) %>%
        mutate(
          # direction of transgressve segregation - smaller than parent
          direction = "-",
          # SE for logistic distribution, for the weighted binomial regression
          # SE = pi/sqrt(3*(n_e + n_c))
          SE = pi/sqrt(3*(
            dat[, paste("N", i, sep = ".")] + dat[, paste("N", h, sep = ".")]
          ))
        )
    )
  }
}

mean.dif.all <- bind_rows(
  ### Difference with mother species ###
  bind_rows(hybLS_spL, hybSL_spS) %>%
    mutate(parental = "Mother"),
  ### Difference with father species ###
  bind_rows(hybLS_spS, hybSL_spL) %>%
    mutate(parental = "Father")
  ) %>%
  drop_na(lnRR.sv) %>%
  left_join(., dat)

dat.full <- mean.dif.all %>%
  # Assign overdoinance to 1, no TS to 0 for each effect size
  mutate(TS = ifelse(lnRR.es < 0, 1, 0)) %>%
  ### Join with metadata ###
  left_join(
    .,
    read.xlsx(
      "../data/original.data.xlsx", sheet = "Metadata"
      )
    ) %>%
  mutate_at(vars(divergence.cytb:surv.relat.hyb21), as.numeric) %>%
  mutate_at(
    vars(contains("divergence"), contains("surv.relat")), scale
    ) %>%
  as.data.frame %>%
  select(-trait) %>%
  mutate_at("taxa", as.factor) %>%
  within(levels(TS) <- c("No", "Transgressive segregation")) %>%
  within(
    taxa <- ordered(
      taxa,
      levels = c("Neuroptera", "Coleoptera", "Diptera", "Lepidoptera", "Orthoptera", "Aves", "Rodentia", "Anura", "Cichliformes")
      )
    ) %>%
  drop_na(hetero.sex, pheno.div.diff, trait.type, divergence.COI) %>%
  # Insect or no
  mutate(
    insect = ifelse(taxa %in% c("Aves", "Rodentia", "Anura", "Cichliformes"), "no", "insect"),
  )

write.csv(dat.full, "../data/mean.ES.TS.csv", row.names = F)

```
# Phylogeny

```{r phylogeny}

#++++++++++++++++++++++++++++++++++++++++++++++++++++++#
# Read create tree based on Open Tree of Life taxonomy
#++++++++++++++++++++++++++++++++++++++++++++++++++++++#

# # matching names from open tree taxonomy
# taxa <- tnrs_match_names(
#   names = levels(dat.full$spL.name) %>%
#     str_replace_all("_", " "),
#   context_name = "Animals"
#   )
# 
# # fixing names with more than 1 match after checking duplicated matches
# inspect(taxa, ott_id = taxa$ott_id[taxa$number_matches != 1][1])
# taxa[taxa$number_matches != 1, ][1,] <-
#   inspect(taxa, ott_id = taxa$ott_id[taxa$number_matches != 1][1])[1,]
# inspect(taxa, ott_id = taxa$ott_id[taxa$number_matches != 1][2])
# taxa[taxa$number_matches != 1, ][2,] <-
#   inspect(taxa, ott_id = taxa$ott_id[taxa$number_matches != 1][2])[1,]
# inspect(taxa, ott_id = taxa$ott_id[taxa$number_matches != 1][3])
# taxa[taxa$number_matches != 1, ][3,] <-
#   inspect(taxa, ott_id = taxa$ott_id[taxa$number_matches != 1][3])[1,]
# inspect(taxa, ott_id = taxa$ott_id[taxa$number_matches != 1][4])
# taxa[taxa$number_matches != 1, ][4,] <-
#   inspect(taxa, ott_id = taxa$ott_id[taxa$number_matches != 1][4])[1,]
# 
# # Create tree
# tree <- tol_induced_subtree(ott_ids = taxa$ott_id)
# tree$tip.label %<>%
#   strip_ott_ids # remove OTT IDs from tip labels
# # randomly solve non-binary phylogeny
# set.seed(6)
# bin.tree <- multi2di(tree, random = T)
# print("Randomly solved phylogeny")
# 
# # Indicate mismatch between tip labels & dataset species names
# setdiff(levels(as.factor(bin.tree$tip.label)), levels(mean.dif.all$spL.name))
# setdiff(levels(mean.dif.all$spL.name), levels(as.factor(bin.tree$tip.label)))
# # Fix names of tip labels
# bin.tree$tip.label %<>% str_replace_all("Dryophytes", "Hyla")
# 
# write.tree(bin.tree, file= "../data/phylo.mean.TS.tre")

#++++++++++++++++++++++++++++++++++#
# Phylogenetic tree for mcmcglmm 
#++++++++++++++++++++++++++++++++++#

# compute branch lengths of tree
phylo_branch <- read.tree(file = "../data/phylo.mean.TS.tre") %>%
  compute.brlen(method = "Grafen", power = 1)
plot(phylo_branch)

# saving phylogeneic matrix
phylo_cor <- vcv(phylo_branch, cor = T)

# generating inverse phylogenetic matrix for MCMCglmm
phylo_branch$node.label <- NULL
phylo_MCMC <- MCMCglmm::inverseA(phylo_branch, nodes = "ALL", scale = TRUE)$Ainv

```

# Frequency of TS
How frequent the TS is?  

```{r freq of transgression}

### N of TS in each taxa and each direction ###
summary <- bind_rows(
  # All observations
  dat.full %>%
    group_by(taxa) %>%
    summarise(
      'Species pair' = length(unique(species.pair)),
      Observations = length(unique(ES.ID)),
      Study = length(unique(Study.ID))
      ) %>%
    mutate(direction = "All Observations")
  ,
  # TS for any direction
  dat.full %>%
    filter(TS == "1") %>%
    group_by(taxa) %>%
    summarise(
      'Species pair' = length(unique(species.pair)),
      Observations = length(unique(ES.ID)),
      Study = length(unique(Study.ID))
      ) %>%
    mutate(direction = "All transgression")
  ,
  # TS for each direction
  dat.full %>%
    filter(TS == "1") %>%
    group_by(taxa, direction) %>%
    summarise(
      'Species pair' = length(unique(species.pair)),
      Observations = length(unique(ES.ID)),
      Study = length(unique(Study.ID))
      )
  ) %>%
  # Assign 0 for no observation of TS
  replace(., is.na(.), "0") %>% 
  # Make tidy data
  gather(key = metrics, value = N, -c(taxa, direction)) %>%
  # Order factors
  mutate_at(vars("metrics", "direction"), as.factor) %>%
  filter(metrics != "Study")

# Order taxon
summary$metrics <- ordered(summary$metrics, levels = c("Study", "Species pair", "Observations"))
# Order TS category
summary$direction <- ordered(summary$direction, levels = c("All Observations", "All transgression", "+", "-"))
# Change names of TS category to more intuitive name
levels(summary$direction) <- c("All Observations", "All transgression", "Exceed upper range", "Exceed lower range")

### Plot ###
plot <- ggplot(
  # rename levels of factors to wrap label text
  summary %>%
    within(levels(direction) <- c("All Obser- vations", "All trans- gression", "Exceed upper range", "Exceed lower range")) %>%
    within(levels(metrics) <- c("Study", "Species pair", "Obser- vations")), 
  aes(x = "", y = N, fill = taxa)) +
  geom_bar(width = 1, stat = "identity") +
  scale_fill_brewer(palette = "YlGn") +
  facet_grid(
    scale = "free", metrics ~ direction,
    # strip text into two lines
    labeller = label_wrap_gen(width = 10)
    ) +
  xlab("") + ylab("") +
  theme(
    strip.text = element_text(size = 10),
    axis.text.y = element_text(size = 10),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    axis.ticks.x = element_blank(),
    legend.text = element_text(size = 11),
    legend.background = element_rect("grey95")
  )
plot

ggsave(
  plot = plot, 
  file = "../Analysis/mean.TS.frequency.svg", height = 3.7, width = 5.0
  )

### Total number of observations and percentage ###
summary %>%
  group_by(direction, metrics) %>%
  # Count number of observaitons and species pairs
  summarise(sum(N)) %>%
  spread(key = metrics, value = "sum(N)") %>%
  as.data.frame() %>%
  # Calculate percentage
  mutate(
    'Species pair %' = .[, "Species pair"]/.[1, "Species pair"]*100,
    'Observaton %' = Observations/.[1, "Observations"]*100
  ) %>%
  mutate_at(vars(contains("percent")), round, 2) %>%
  kable("html", digits = 3) %>% kable_styling("striped", position = "left")


```

# Seeking factor influences the frequency of TS
Previous study (Stelkens et al 2009 Evolution) showed TS in F1 become frequent as parental species diverges in plant. How about male sexual traits in animals?  
Does TS biased toward larger phenotypic value? -> <i>parentalspS</i> will negative   
Does TS biased toward father species? -> <i>patmatmother</i> will negative



```{r mixed model}

for (k in c("alltaxon", "insect")) {
  
  if (k == "alltaxon") {
    dat <- dat.full
  } else {
    dat <- dat.full %>% 
      filter(insect == k)
  }

  # ### Setting prior to logistic regression ###
  # prior <- list(
  #   B=list(
  #     mu = rep(0, 17), # N of coefficient. (level -1) for categorical factors, 1 for continuous factors, 1 for intercept
  #     V = gelman.prior(~
  #       parental*hetero.sex +
  #       parental*direction +
  #       direction*divergence.COI + direction*pheno.div.ratio +
  #       direction*hetero.sex +
  #       direction*trait.type +
  #       direction*distribution + direction*reciprocal,
  #     data = dat, # formula and data
  #     scale=sqrt(pi^2/3+1))), # error distribution of logistic regression
  #   R=list(V=1,fix=1),
  #   G = list(
  #     G1 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
  #     G2 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
  #     G3 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
  #     G4 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000)
  #     )
  #   )
  # ## Phylogenetic binomial regression ###
  # phylmix <-MCMCglmm(
  #   fixed = TS ~
  #     parental*hetero.sex + parental*direction +
  #     direction*divergence.COI + direction*pheno.div.ratio +
  #     direction*hetero.sex + direction*trait.type +
  #     direction*distribution + direction*reciprocal,
  #   # idh(SE):units | weight by SE of effect size
  #   random = ~ Study.ID + Cross.ID + spL.name + idh(SE):units,
  #   family = "categorical",
  #   verbose = FALSE,
  #   ginverse = list(spL.name = phylo_MCMC),
  #   prior = prior,
  #   data = dat,
  #   nitt = 60000,  # Increase the number of iterations, default is 13000
  #   burnin = 5000  # Increase the number of burnin, default is 3000
  # )
  # phylmix$Sol <- phylmix$Sol/sqrt(1+c2)
  # ### Save model ###
  # saveRDS(phylmix, file = paste("../Analysis/Mean.transgression.allfactors", k, "obj", sep = "."))


### Load model ###
phylmix <- readRDS(paste("../Analysis/Mean.transgression.allfactors", k, "obj", sep = "."))

sum <- left_join(
  # corrected estimates & SD
  summary(phylmix$Sol)$statistics %>%
    as.data.frame() %>%
    rownames_to_column(var = "factors"),
  # P
  summary(phylmix)$solutions %>%
  as.data.frame() %>%
    rownames_to_column(var = "factors"),
  by = "factors"
  ) %>%
  mutate(significance = ifelse(pMCMC < 0.05, "*", "")) %>%
    ### Grouping factors ###
    mutate(
      group = 
        ifelse(str_detect(factors, "direction.:"), 
               "Exceed upper range",
               ifelse(str_detect(factors, "parentalMother:"),
                      "Exceed mother",
                      ifelse(factors == "hetero.sexMale:direction+",
                             "Exceed upper range",
                             "Transgression for both direction"
                             )
                      )
               )
    ) %>%
    mutate_at("group", as.factor) %>%
    within(group <- ordered(group, c("Transgression for both direction", "Exceed upper range", "Exceed mother"))) %>%
    ### Change factor names ###
    within(
      factors <- str_remove_all(
        factors, "direction.:"
        ) %>%
        str_remove_all(., "parentalMother:") %>%
        str_remove_all(., ":direction.")
      ) %>%
    within(
      factors <- factor(
        factors, ordered = TRUE, 
        levels = c("parentalMother", "direction+", "trait.typesound", "hetero.sexMale", "reciprocalViable", "distributionOverlap", "pheno.div.ratio",  "divergence.COI",  "(Intercept)")
        )
      )
  levels(sum$factors) <- c("Exceed mother", "Exceed upper range", "Sound traits", "Male heterogametic", "Viable reciprocal hybrids", "Distribution overlap", "Phenotypic divergence", "Genetic divergence", "Intercept")

  ### Plot ###
  metaplot <- ggplot(sum, aes(
    x = post.mean, y = factors
    )) +
    # Vertical line
    geom_vline(
      xintercept = 0, size = 0.2, 
      colour = "grey30", linetype = "dotted"         
      ) +
    # CI
    geom_errorbarh(
      aes(
        xmin = sum[, 'l-95% CI'], xmax = sum[, 'u-95% CI'],
        colour=significance 
        ), 
      height = .0001
      ) +
    # Color of plots and errorbars
    scale_colour_manual(values = c("grey60", "black")) +
    geom_point(size = 1, aes(colour = significance)) +
    scale_fill_manual(values = c("grey60", "black")) +
    # Title
    ggtitle(k) +
    ylab("") + xlab("Estimate with 95% CI") +
    # Combine different plots for main factors and interactions
    facet_grid(
      group~., scales = "free", space = "free",
      labeller = label_wrap_gen(width = 20)
      ) +
    # Themes
    foresttheme
print(metaplot)

  ggsave(
      plot = metaplot, 
      file = paste("../Analysis/mean.TS.result", k, "svg", sep = "."), 
      height = 4.7, width = 4.0
      )

  ### Output result ###
  sum %>% 
    select(group, factors, Mean, SD, pMCMC, significance) %>%
    mutate_at(c("Mean", "SD"), round, 2) %>%
    mutate_at(c("pMCMC"), round, 3) %>%
    print()

  # transformation for estimate
  # summary(phylmix$Sol/sqrt(1+c2))
  # transformation for varaince
  summary(phylmix$VCV/(1+c2)) %>% 
    print()

}
```



```{r continuous factors plot}

# +++++++++++++++++++++++++++++++++++++++++++#
# To set raw metadata in X axis, reload raw metadata and combine to transgression dataset
# +++++++++++++++++++++++++++++++++++++++++++#
rawdat <- dat.full %>%
  select(-pheno.div.ratio, -divergence.COI) %>%
  # lnRR between parental species as phenotypic distance
  mutate(pheno.div.ratio = log(Mn.spL/Mn.spS)) %>%
  left_join(
    .,
    read.xlsx("../data/original.data.xlsx", sheet = "Metadata") %>%
      select(Cross.ID, divergence.COI)
    ) %>%
  # Natural log of genetic distance
  mutate_at("divergence.COI", log) %>%
  mutate_at("direction", as.factor)

# +++++++++++++++++++++++++++++++++++++++++++#
# To draw regression line separatory in transgression for larger mean and smaller mean, create two dataset
# +++++++++++++++++++++++++++++++++++++++++++#
# Dataset including non TS & TS for larger mean
dat.TS.larger <- filter(rawdat, direction == "+")
# Dataset including non TS & TS for smaller mean
dat.TS.smaller <- filter(rawdat, direction == "-")

# # +++++++++++++++++++++++++++++++++++++++++++#
# # Regression: Genetic distance
# # +++++++++++++++++++++++++++++++++++++++++++#
# 
# ### Setting prior to logistic regression ###
# prior <- list(
#   B=list(
#     mu = rep(0, 3), # N of coefficient. (level -1) for categorical factors, 1 for continuous factors, 1 for intercept
#     V = gelman.prior(~ direction:divergence.COI + divergence.COI,
#     data = rawdat, # formula and data
#     scale=sqrt(pi^2/3+1))), # error distribution of logistic regression
#   R=list(V=1,fix=1),
#   G = list(
#     G1 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#     G2 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#     G3 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#     G4 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000)
#     )
#   )
# ## Phylogenetic binomial regression ###
# phylmix <-MCMCglmm(
#   fixed = TS ~ direction:divergence.COI + divergence.COI,
#   # idh(SE):units | weight by SE of effect size
#   random = ~ Study.ID + Cross.ID + spL.name + idh(SE):units,
#   family = "categorical",
#   verbose = FALSE,
#   ginverse = list(spL.name = phylo_MCMC),
#   prior = prior,
#   data = rawdat,
#   nitt = 60000,  # Increase the number of iterations, default is 13000
#   burnin = 5000  # Increase the number of burnin, default is 3000
# )
# phylmix$Sol <- phylmix$Sol/sqrt(1+c2)
# ### Save model ###
# saveRDS(phylmix, file ="../Analysis/Mean.transgression.divergence.COI.obj")
# 
# # +++++++++++++++++++++++++++++++++++++++++++#
# # Regression: Phenotypic divergence
# # +++++++++++++++++++++++++++++++++++++++++++#
# ### Setting prior to logistic regression ###
# prior <- list(
#   B=list(
#     mu = rep(0, 3), # N of coefficient. (level -1) for categorical factors, 1 for continuous factors, 1 for intercept
#     V = gelman.prior(~ direction:pheno.div.ratio + pheno.div.ratio,
#     data = rawdat, # formula and data
#     scale=sqrt(pi^2/3+1))), # error distribution of logistic regression
#   R=list(V=1,fix=1),
#   G = list(
#     G1 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#     G2 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#     G3 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#     G4 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000)
#     )
#   )
# ## Phylogenetic binomial regression ###
# phylmix <-MCMCglmm(
#   fixed = TS ~ direction:pheno.div.ratio + pheno.div.ratio,
#   # idh(SE):units | weight by SE of effect size
#   random = ~ Study.ID + Cross.ID + spL.name + idh(SE):units,
#   family = "categorical",
#   verbose = FALSE,
#   ginverse = list(spL.name = phylo_MCMC),
#   prior = prior,
#   data = rawdat,
#   nitt = 60000,  # Increase the number of iterations, default is 13000
#   burnin = 5000  # Increase the number of burnin, default is 3000
# )
# phylmix$Sol <- phylmix$Sol/sqrt(1+c2)
# ### Save model ###
# saveRDS(phylmix, file ="../Analysis/Mean.transgression.pheno.div.ratio.obj")

#++++++++++++++++++++++++++++++++++++++++++++++++++#
# Plot
#++++++++++++++++++++++++++++++++++++++++++++++++++#
for (i in c("divergence.COI", "pheno.div.ratio")) {
  
  ### Load model ###
  phylmix <- readRDS(
    paste("../Analysis/Mean.transgression",i, "obj", sep = ".")
    )
  reg <- summary(phylmix$Sol)$statistics %>%
      as.data.frame()
  
  ### Plot ###
  plot <- ggplot(rawdat, aes(x = rawdat[,i], y = rawdat[, "TS"])) +
    geom_jitter(height = 0.1, width = 0, aes(color = direction), alpha = 0.3, size = 0.2) +
    # Transgression for larger mean
    stat_function(
      aes(color = "+"), size = 0.8,
      fun = function(x) 
        1/(1 + exp(-(reg[1,1] + x*(reg[2,1]+reg[3,1]))))
      ) +
    # Transgression for smaller mean
    stat_function(
      aes(color = "-"), size = 0.8,
      fun = function(x) 
        1/(1 + exp(-(reg[1,1] + x*reg[2,1])))
      ) +
    ylab("") + xlab("") +
    scale_color_manual(values = c("#648FFF", "#FE6100")) + 
    scale_y_continuous(breaks=seq(0,1)) +
    theme_bw() +
    theme(
      legend.position = "none",
      axis.ticks = element_line(size = 0.3, color = "grey50"),
      axis.text = element_text(size = 9.5, color = "black"),
      axis.text.y = element_blank(),
      panel.grid.major.y = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_rect(colour = "grey50", size = 0.7),
      strip.text = element_text(size = 9.5, color = "black")
      )
  print(plot)
  ggsave(
    plot = plot + theme(axis.title  = element_blank()), 
    file = paste("../Analysis/mean.TS.continuous", i, "svg", sep = "."), 
    height = 1.6, width = 1.7
    )

}

```



```{r Direct test for the significant categorical factors, results='asis'}

for (i in c("reciprocal", "trait.type")) {
  for (k in c("alltaxon", "insect")) {

    if (k == "alltaxon") {
      dat <- dat.full
    } else {
      dat <- dat.full %>% 
        filter(insect == k)
    }

    # Make new categorical data combining direction of TS and target categorical factor
    dat %<>%
      mutate(interaction = str_c(direction, .[, i], sep = "_"))
    
    
    # ### Setting prior to logistic regression ###
    # prior <- list(
    #   B=list(
    #     mu = rep(0, 4), # N of coefficient. (level -1) for categorical factors, 1 for continuous factors, 1 for intercept
    #     V = gelman.prior(~ interaction, # + trait.direction
    #     data = dat, # formula and data
    #     scale=sqrt(pi^2/3+1))), # error distribution of logistic regression
    #   R=list(V=1,fix=1),
    #   # Replicating same G for the number of random effects (here, 4)
    #   G = list(
    #     G1 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
    #     G2 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
    #     G3 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
    #     G4 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000)
    #     )
    #   )
    # 
    # phylmix <-MCMCglmm(
    #   fixed = TS ~  interaction -1, # + trait.direction
    #   family = "categorical",
    #   # idh(SE):units | weight by SE of effect size
    #   random = ~ Study.ID + Cross.ID + spL.name + idh(SE):units,
    #   verbose = FALSE,
    #   ginverse = list(spL.name = phylo_MCMC),
    #   prior = prior,
    #   data = dat
    # )
    # # Correct model result
    # phylmix$Sol <- phylmix$Sol/sqrt(1+c2)
    # ### Save model ###
    # saveRDS(
    #   phylmix,
    #   file =
    #     paste("../Analysis/Mean.transgression", i,k, "obj", sep = ".")
    #     )

    ### Load model ###
    phylmix <- readRDS(
      paste("../Analysis/Mean.transgression", i,k, "obj", sep = ".")
      )
  
    sum <- left_join(
      # corrected estimates & SD
      summary(phylmix$Sol)$statistics %>%
        as.data.frame() %>%
        rownames_to_column(var = "factors"),
      # P
      summary(phylmix)$solutions %>%
      as.data.frame() %>%
      rownames_to_column(var = "factors"),
      by = "factors"
      ) %>%
      mutate(
        significance = ifelse(pMCMC < 0.05, "*", ""),
        direction =
          ifelse(str_detect(factors, "\\+"), "Exceed upper range",
                 ifelse(str_detect(factors, "\\-"), "Exceed lower range",
                        ifelse(str_detect(factors, "Father_"), "Exceed father", "Exceed mother")
                        )
                 )
        )
  
    ### Plot ###
    categoricalplot <- ggplot(sum, aes(x = post.mean, y = factors)) +
      # Vertical line
      geom_vline(
        xintercept = 0, size = 0.3,
        colour = "grey30", linetype = "dotted"
        ) +
      # CI
      geom_errorbarh(
        aes(xmin = sum[, 'l-95% CI'], xmax = sum[, 'u-95% CI']),
        height = .0001
        ) +
      geom_point(size = 1.3, shape = 17) +
      # Title
      ylab("") + xlab("") +
      # Combine different plots for main factors and interactions
      facet_grid(
        direction ~., scales = "free", drop = TRUE,
        labeller = label_wrap_gen(width = 11)
        ) +
      foresttheme
    print(categoricalplot)
  
    ggsave(
        plot = categoricalplot + theme(axis.text.y = element_blank()),
        file = paste("../Analysis/Mean.TS.categorical", i,k, "svg", sep = "."),
        height = 1.8, width = 2.5
        )
    
  #+++++++++++++++++++++++++++++++++++#
  # Contrast
  #+++++++++++++++++++++++++++++++++++#
  
  bind_rows(
    HPDinterval(phylmix$Sol[,1] - phylmix$Sol[,2]) %>%
      as.data.frame() %>%
      mutate(
        from = row.names(summary(phylmix)$solutions)[1],
        to = row.names(summary(phylmix)$solutions)[2]
        ),
    HPDinterval(phylmix$Sol[,1] - phylmix$Sol[,3]) %>%
      as.data.frame() %>%
      mutate(
        from = row.names(summary(phylmix)$solutions)[1],
        to = row.names(summary(phylmix)$solutions)[3]
        ),
    HPDinterval(phylmix$Sol[,1] - phylmix$Sol[,4]) %>%
      as.data.frame() %>%
      mutate(
        from = row.names(summary(phylmix)$solutions)[1],
        to = row.names(summary(phylmix)$solutions)[4]
        ),
    HPDinterval(phylmix$Sol[,2] - phylmix$Sol[,3]) %>%
      as.data.frame() %>%
      mutate(
        from = row.names(summary(phylmix)$solutions)[2],
        to = row.names(summary(phylmix)$solutions)[3]
        ),
    HPDinterval(phylmix$Sol[,2] - phylmix$Sol[,4]) %>%
      as.data.frame() %>%
      mutate(
        from = row.names(summary(phylmix)$solutions)[2],
        to = row.names(summary(phylmix)$solutions)[4]
        ),
    HPDinterval(phylmix$Sol[,3] - phylmix$Sol[,4]) %>%
      as.data.frame() %>%
      mutate(
        from = row.names(summary(phylmix)$solutions)[3],
        to = row.names(summary(phylmix)$solutions)[4]
        )
    ) %>%
    as.data.frame() %>%
    mutate(
      sign = ifelse((upper < 0), "-", ifelse(lower > 0, "+", ""))
      ) %>%
    mutate_at(
      vars("from", "to"), 
      funs(
        str_replace_all(., pattern = "interaction", replacement = "direction")
        )
      ) %>%
    select(from, to, upper, lower, sign) %>%
    kable("html", digits = 3) %>% 
    kable_styling("striped", position = "left") %>%
    print()
    
  }
}


```
```{r include = FALSE}

# for (i in c("divergence.COI", "pheno.div.ratio")) {
#   
#   # Transgression for larger mean
#   reg.larger <- glm(
#     TS ~ dat.TS.larger[, i], 
#     data = dat.TS.larger, family = binomial
#     )$coefficients %>%
#     as.vector
#   # Transgression for smaller mean
#   reg.smaller <- glm(
#     TS ~ dat.TS.smaller[, i], 
#     data = dat.TS.smaller, family = binomial
#     )$coefficients %>%
#     as.vector
# 
#   plot <- ggplot(rawdat, aes(x = rawdat[,i], y = rawdat[, "TS"])) +
#       geom_jitter(height = 0.1, width = 0, aes(color = direction), alpha = 0.3, size = 0.5) +
#       # Transgression for larger mean
#       stat_function(
#         aes(color = "+"), size = 1,
#         fun = function(x) 
#           1/(1 + exp(-(reg.larger[1] + x*reg.larger[2])))
#         ) +
#       # Transgression for smaller mean
#       stat_function(
#         aes(color = "-"), size = 1,
#         fun = function(x) 
#           1/(1 + exp(-(reg.smaller[1] + x*reg.smaller[2])))
#         ) +
#       ylab("") + xlab("") +
#       scale_color_manual(values = c("#648FFF", "#FE6100")) + 
#       scale_y_continuous(breaks=seq(0,1)) +
#       theme_bw() +
#       theme(
#         legend.position = "none",
#         panel.grid.major.y = element_blank(),
#         panel.grid.minor = element_blank(),
#         axis.text.x = element_text(size = 13),
#         axis.text.y = element_blank(),
#         axis.title  = element_text(size = 15),
#         panel.border = element_rect(colour = "grey70", size = 1)
#         )
#   print(plot)
#   ggsave(
#     plot = plot, 
#     file = paste("../Analysis/mean.TS.continuous", i, "svg", sep = "."), 
#     height = 2.5, width = 2.7
#     )
# 
# }

# fit = glm(
#   TS ~ divergence.COI*direction,
#   data = rawdat,
#   family = binomial
#   )
# ggPredict(fit, se = TRUE, interactive = TRUE, digits = 3)

```