---
title: "Data description"
author: "Keisuke Atsumi"
date: '`r format(Sys.time(), "%y/%m/%d %H:%M")`'
output:
  html_document:
    code_folding: hide
    theme: united
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}

rm(list=ls())  # reset workspace
options(scipen=100)  # do not show numbers using exponential

# install & load packages
pacman::p_load(
  tidyverse,
  knitr,
  svglite
)
opts_chunk$set(prompt=TRUE, message=FALSE, comment="", warning = FALSE) 

```

```{r custom function}

# check multicolinearity (calculate VIF)
# https://github.com/pedroj/RCode_Master_UPO/blob/master/Statistical%20protocol_Zuur%20etal/sm001/HighstatLib.r

#VIF
myvif <- function(mod) {
  v <- vcov(mod)
  assign <- attributes(model.matrix(mod))$assign
  if (names(coefficients(mod)[1]) == "(Intercept)") {
    v <- v[-1, -1]
    assign <- assign[-1]
  } else warning("No intercept: vifs may not be sensible.")
  terms <- labels(terms(mod))
  n.terms <- length(terms)
  if (n.terms < 2) stop("The model contains fewer than 2 terms")
  if (length(assign) > dim(v)[1] ) {
     diag(tmp_cor)<-0
     if (any(tmp_cor==1.0)){
        return("Sample size is too small, 100% collinearity is present")
     } else {
        return("Sample size is too small")
     }
  }
  R <- cov2cor(v)
  detR <- det(R)
  result <- matrix(0, n.terms, 3)
  rownames(result) <- terms
  colnames(result) <- c("GVIF", "Df", "GVIF^(1/2Df)")
  for (term in 1:n.terms) {
    subs <- which(assign == term)
    result[term, 1] <- det(as.matrix(R[subs, subs])) * det(as.matrix(R[-subs, -subs])) / detR
    result[term, 2] <- length(subs)
  }
  if (all(result[, 2] == 1)) {
    result <- data.frame(GVIF=result[, 1])
  } else {
    result[, 3] <- result[, 1]^(1/(2 * result[, 2]))
  }
  invisible(result)
}

corvif <- function(dataz) {
    dataz <- as.data.frame(dataz)
    #correlation part
    cat("Correlations of the variables\n\n")
    tmp_cor <- cor(dataz,use="complete.obs")
    print(tmp_cor)

    #vif part
    form    <- formula(paste("fooy ~ ",paste(strsplit(names(dataz)," "),collapse=" + ")))
    dataz   <- data.frame(fooy=1,dataz)
    lm_mod  <- lm(form,dataz)

    cat("\n\nVariance inflation factors\n\n")
    print(myvif(lm_mod))
}

myvif <- function(mod) {
  v <- vcov(mod)
  assign <- attributes(model.matrix(mod))$assign
  if (names(coefficients(mod)[1]) == "(Intercept)") {
    v <- v[-1, -1]
    assign <- assign[-1]
  } else warning("No intercept: vifs may not be sensible.")
  terms <- labels(terms(mod))
  n.terms <- length(terms)
  if (n.terms < 2) stop("The model contains fewer than 2 terms")
  if (length(assign) > dim(v)[1] ) {
     diag(tmp_cor)<-0
     if (any(tmp_cor==1.0)){
        return("Sample size is too small, 100% collinearity is present")
     } else {
        return("Sample size is too small")
     }
  }
  R <- cov2cor(v)
  detR <- det(R)
  result <- matrix(0, n.terms, 3)
  rownames(result) <- terms
  colnames(result) <- c("GVIF", "Df", "GVIF^(1/2Df)")
  for (term in 1:n.terms) {
    subs <- which(assign == term)
    result[term, 1] <- det(as.matrix(R[subs, subs])) * det(as.matrix(R[-subs, -subs])) / detR
    result[term, 2] <- length(subs)
  }
  if (all(result[, 2] == 1)) {
    result <- data.frame(GVIF=result[, 1])
  } else {
    result[, 3] <- result[, 1]^(1/(2 * result[, 2]))
  }
  invisible(result)
}



corvif <- function(dataz) {
    dataz <- as.data.frame(dataz)
    #correlation part
    cat("Correlations of the variables\n\n")
    tmp_cor <- cor(dataz,use="complete.obs")
    print(tmp_cor)

    #vif part
    form    <- formula(paste("fooy ~ ",paste(strsplit(names(dataz)," "),collapse=" + ")))
    dataz   <- data.frame(fooy=1,dataz)
    lm_mod  <- lm(form,dataz)

    cat("\n\nVariance inflation factors\n\n")
    print(myvif(lm_mod))
}


### mytheme in ggplot ###

mytheme <- 
  theme(
    panel.grid = element_blank(),
    axis.title = element_text(size=12),
    axis.text = element_text(size=11),
    axis.text.x = element_text(angle = 30, hjust = 1),
    strip.text = element_text(size=12, lineheight=5.0),
    strip.background = element_rect(fill = "lightgrey")
  )


```

# Summarizing dataset
Summarize data for variation only because the data will be the same for mean data for following reasons:   
- variation data removes NAs for variance measures which did not yet for mean data, though NAs for variance measures will be elimated later in mean data as well    
- no data was removed in variation data other than the reasons above  
*original* : no observations were removed  
*fullcross* : observations with both reciprocal cross ... used in comparing paternal/maternal effect in the analysis *general patterns*  
*fullmodifiers* : observations with all modifiers ... used in transgressive segregation meta-regression  
*full* : observations with both reciprocal cross and all modifiers ... used in meta-regression for paternal/maternal effect in the analysis *general patterns*

```{r mean data}


### original data ###
original <- read.csv("../data/dat.CV.csv", head = TRUE) %>%
  within(
  # Order taxon
  taxa <- ordered(
    taxa,
    levels = c(
      "Teleost", "Amphibian", "Bird", "Mammal",
      "Diptera", "Lepidoptera", "Neuroptera", 
      "Orthoptera", "Coleoptera" 
      )
    )
  ) %>%
  group_by(taxa)

### Observations with both reciprocal crosses ###
fullcross <- original %>%
  filter(reciprocal == "Viable")

### Observations with all modifiers ###
fullmodifiers <- original %>%
  drop_na("divergence.COI", "hetero.sex")
  
### Observations with with both reciprocal crosses & all modifiers ###
full <- original %>%
  filter(reciprocal == "Viable") %>%
  drop_na("divergence.COI", "hetero.sex")
  

for (i in c("original", "fullcross", "fullmodifiers", "full")) {

  summary <- get(i) %>%
    group_by(taxa) %>%
    summarise(
      species.pair = length(unique(species.pair)),
      observations = length(unique(ES.ID)),
      study = length(unique(Study.ID))
      )
  
  print(i)
  print(
    bind_rows(
      summary,
      summary %>%
        summarise_if(is.numeric, sum) %>%
        mutate(taxa = "total")
      ) %>%
      column_to_rownames(var = "taxa")
    )
  
  # Order by taxon
  
  sum.forplot <- summary %>% 
    gather(key = metrics, value = N, -taxa) %>%
    within(
      metrics <- ordered(
        metrics,
        levels = c(
          "study", "species.pair", "observations"
          )
        )
      )
  
  
  plot <- ggplot(sum.forplot, aes(x = "", y = N, fill = taxa)) +
    geom_bar(width = 1, stat = "identity") +
    scale_fill_brewer() +
    facet_grid(scale = "free", rows = "metrics") +
    xlab(i) +
    mytheme
  print(plot)
  
  if(i == "fullmodifiers") {
    ggsave(
      plot = plot, 
      file = "../Analysis/data.fullmodifiers.svg",
      height = 4.5, width = 3.5
    )
  }else{
    }

}


```
