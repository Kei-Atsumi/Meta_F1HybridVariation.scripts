---
title: "Mean Step 2 ES calculation for general pattern"
author: "Keisuke Atsumi"
date: '`r format(Sys.time(), "%y/%m/%d %H:%M")`'
output:
  html_document:
    code_folding: hide
    theme: united
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}

rm(list=ls())  # reset workspace
options(scipen=100)  # do not show numbers using exponential

# install & load packages
# install.packages("tidyverse" ,"metafor", "openxlsx", "data.table")
library(tidyverse)  # dataset modification
library(metafor)    # meta-analysis!
library(knitr)
library(phytools)
library(rotl)
library(MCMCglmm)
library(svglite)
opts_chunk$set(prompt=TRUE, message=FALSE, comment="") 

############################################################
# check multicolinearity (calculate VIF)
############################################################

# https://github.com/pedroj/RCode_Master_UPO/blob/master/Statistical%20protocol_Zuur%20etal/sm001/HighstatLib.r

myvif <- function(mod) {
  v <- vcov(mod)
  assign <- attributes(model.matrix(mod))$assign
  if (names(coefficients(mod)[1]) == "(Intercept)") {
    v <- v[-1, -1]
    assign <- assign[-1]
  } else warning("No intercept: vifs may not be sensible.")
  terms <- labels(terms(mod))
  n.terms <- length(terms)
  if (n.terms < 2) stop("The model contains fewer than 2 terms")
  if (length(assign) > dim(v)[1] ) {
     diag(tmp_cor)<-0
     if (any(tmp_cor==1.0)){
        return("Sample size is too small, 100% collinearity is present")
     } else {
        return("Sample size is too small")
     }
  }
  R <- cov2cor(v)
  detR <- det(R)
  result <- matrix(0, n.terms, 3)
  rownames(result) <- terms
  colnames(result) <- c("GVIF", "Df", "GVIF^(1/2Df)")
  for (term in 1:n.terms) {
    subs <- which(assign == term)
    result[term, 1] <- det(as.matrix(R[subs, subs])) * det(as.matrix(R[-subs, -subs])) / detR
    result[term, 2] <- length(subs)
  }
  if (all(result[, 2] == 1)) {
    result <- data.frame(GVIF=result[, 1])
  } else {
    result[, 3] <- result[, 1]^(1/(2 * result[, 2]))
  }
  invisible(result)
}

corvif <- function(dataz) {
    dataz <- as.data.frame(dataz)
    #correlation part
    cat("Correlations of the variables\n\n")
    tmp_cor <- cor(dataz,use="complete.obs")
    print(tmp_cor)

    #vif part
    form    <- formula(paste("fooy ~ ",paste(strsplit(names(dataz)," "),collapse=" + ")))
    dataz   <- data.frame(fooy=1,dataz)
    lm_mod  <- lm(form,dataz)

    cat("\n\nVariance inflation factors\n\n")
    print(myvif(lm_mod))
}

mytheme <- 
  theme(
    panel.grid = element_blank(),
    axis.title = element_text(size=12),
    axis.text = element_text(size=11),
    axis.text.x = element_text(angle = 30, hjust = 1),
    strip.text = element_text(size=12, lineheight=5.0),
    strip.background = element_rect(fill = "lightgrey")
  )


```

# Investigation (preliminary): dominance? paternal inheritance?  
To investigate how dominance and paternal inheritance shape male sexual trait in F1 hybrids, here we calculate SMD between pure species and hybrids. lnRR won't work well here: when hybrids are on midparent (i.e. solely additive), the difference between either pure and hybrids will be same in SMD but different in lnRR.

```{r lnRR & SMD between hybrids and parental species}

# load phenotypic data
dat <- read.csv("../data/dat.mean.csv", head = TRUE) %>%
  filter(reciprocal == "Viable")

# Order by taxon
dat$taxa <- ordered(
  dat$taxa,
  levels = c(
    "Teleost", "Amphibian", "Bird", 
    "Diptera", "Lepidoptera", "Neuroptera", 
    "Orthoptera", "Coleoptera" 
    )
  )

levels(dat$taxa)

##############################################################
# Difference between hybrids and smaller species (spS)
##############################################################

for (i in c("hybLS", "hybSL", "spL")) { # identify type of hybrids
  for (h in c("spS")) { # identify type of parentals
    assign(
      paste(i, h, sep = "_"),
      
      left_join(
        ### lnRR ###
        escalc(
          measure = "ROM",
          # N of hybrids
          n1i = dat[, paste("N", i, sep = ".")],
          # N of parentals
          n2i = dat[, paste("N", h, sep = ".")],
          # Mean of hybrids
          m1i = dat[, paste("Mn", i, sep = ".")],
          # Mean of parentals
          m2i = dat[, paste("Mn", h, sep = ".")],
          # SD of hybrids
          sd1i = dat[, paste("SD", i, sep = ".")],
          # SD of parentals
          sd2i = dat[, paste("SD", h, sep = ".")],
          data = dat
          ) %>%
          rename(lnRR.es = yi, lnRR.sv = vi),
        ### SMD ###
        escalc(
          measure = "SMD",
          # N of hybrids
          n1i = dat[, paste("N", i, sep = ".")],
          # N of parentals
          n2i = dat[, paste("N", h, sep = ".")],
          # Mean of hybrids
          m1i = dat[, paste("Mn", i, sep = ".")],
          # Mean of parentals
          m2i = dat[, paste("Mn", h, sep = ".")],
          # SD of hybrids]
          sd1i = dat[, paste("SD", i, sep = ".")],
          # SD of parentals
          sd2i = dat[, paste("SD", h, sep = ".")],
          data = dat
          ) %>%
          rename(SMD.es = yi, SMD.sv = vi)
        ) %>%
        
        select(ES.ID, contains("lnRR"), contains("SMD")) %>%
        # indicate type of hybrid
        mutate(cross = i) 
    )
  }
}

mean.dif <- bind_rows(
  hybLS_spS, hybSL_spS, spL_spS
  ) %>%
  drop_na(SMD.sv) %>%
  arrange(ES.ID) %>%
  left_join(., dat) 

write.csv(
  mean.dif, "../data/mean.ES.general.csv", row.names = F
  )


```

# Phenotypic data sumamry

```{r dataset summary}

summary <- mean.dif %>%
  group_by(taxa) %>%
  summarise(
    species.pair = length(unique(species.pair)),
    observations = length(unique(ES.ID)),
    study = length(unique(Study.ID))
    )

bind_rows(
  summary,
  summary %>%
    summarise_if(is.numeric, sum) %>%
    mutate(taxa = "total")
  ) %>%
  column_to_rownames(var = "taxa")

# Order by taxon

sum.forplot <- summary %>% 
  gather(key = metrics, value = N, -taxa)
sum.forplot$metrics <- ordered(
  sum.forplot$metrics,
  levels = c(
    "study", "species.pair", "observations"
    )
  )

plot <- ggplot(sum.forplot, aes(x = "", y = N, fill = taxa)) +
  geom_bar(width = 1, stat = "identity") +
  scale_fill_brewer() +
  facet_grid(scale = "free", rows = "metrics") +
  xlab("") +
  mytheme
plot

# ggsave(plot = plot, file = "../Analysis/phenodat.additive.svg", height = 5, width = 3.5)

```

# Phylogeny

```{r phylogeny}

# matching names from open tree taxonomy
taxa <- tnrs_match_names(
  names = levels(mean.dif$spL.name) %>%
    str_replace_all("_", " "), 
  context_name = "Animals"
  )

# which names return more than 1 match?
inspect(taxa, ott_id = taxa$ott_id[taxa$number_matches != 1])

# fixing names with more than 1 match
taxa[taxa$number_matches != 1, ] <- 
  inspect(taxa, ott_id = taxa$ott_id[taxa$number_matches != 1])[1, ]

tree <- tol_induced_subtree(ott_ids = taxa$ott_id)
print("Original tree from OTL")
plot(tree, no.margin=TRUE)

# randomly solve non-binary phylogeny
set.seed(6)
bin.tree <- multi2di(tree, random = T) 
print("Randomly solved phylogeny")
plot(bin.tree)

# check tree is binary
is.binary(bin.tree) # TRUE

# correlation matrix to fit to the model
bin.tree$tip.label <- bin.tree$tip.label %>%
  as.factor() 

levels(bin.tree$tip.label) <- levels(mean.dif$spL.name) # making sure names match

bin.tree$tip.label <- as.character(bin.tree$tip.label) # converting names back to character

write.tree(
  bin.tree, 
  file= "../data/phylo.mean.general.tre"
  )

```
  