---
title: "General pattern of phenotypic mean"
author: "Keisuke Atsumi"
date: '`r format(Sys.time(), "%y/%m/%d %H:%M")`'
output:
  html_document:
    code_folding: hide
    theme: united
    toc: yes
    toc_float: yes
---

# Setup 

## Loading packages
```{r setup, include=FALSE}

rm(list=ls())  # reset workspace
sessionInfo()  # show R version etc
options(scipen=100)  # do not show numbers using exponential

# load packages
pacman::p_load(
  tidyverse,
  metafor,
  knitr,
  ape,
  phytools,
  svglite,    # Export SVG plots
  ggbeeswarm, # bee-swarm plots
  plotly     # interactive plots using ggplot2
)
  
opts_chunk$set(prompt=TRUE, message=FALSE, comment="", warning = FALSE)

mytheme <- 
  theme(
    panel.grid = element_blank(),
    axis.ticks.y=element_blank(),
    axis.title = element_text(size=20),
    axis.text = element_text(size=17, color = "black"),
    axis.line.y = element_blank(),
    strip.text = element_text(size=12, lineheight=5.0),
    strip.background = element_rect(fill = "white")
  )

```


## *Phylogenetic data*    

```{r load data}

# Load effect sizes
mean.dif <- read.csv("../data/mean.ES.general.csv", head = TRUE) %>%
  # indicate dataset including TS
  mutate(data.type = "withTS")

# Observations with TS
TS <- read.csv("../data/mean.ES.TS.csv", head = TRUE) %>%
  filter(lnRR.es < 0) %>%
  distinct(ES.ID)
# Effect sizes without observations with TS
noTS <- read.csv("../data/mean.ES.general.csv", head = TRUE) %>%
  filter(!ES.ID %in% unique(TS$ES.ID)) %>%
  # indicate dataset without TS
  mutate(data.type = "withoutTS")

# combine dataset with/without TS
with.without.TS <- bind_rows(mean.dif, noTS) %>%
  mutate(metaunit =  str_c(data.type, cross, sep = "_"))

# Select ESs that can compare maternal and paternal inheritance
hybrids <- mean.dif %>%
  filter(cross != "spL")

# compute branch lengths of tree
phylo_branch <- read.tree(file = "../data/phylo.mean.general.tre") %>%
  compute.brlen(bin.tree, method = "Grafen", power = 1)

# check tree is ultrametric
is.ultrametric(phylo_branch) # TRUE

# saving phylogeneic matrix
phylo_cor <- vcv(phylo_branch, cor = T)

# generating inverse phylogenetic matrix for MCMCglmm
# Note one of the tips is called "Lates calcarifer (estimated)"
phylo_branch$node.label <- NULL
phylo_MCMC <- MCMCglmm::inverseA(phylo_branch, nodes = "ALL", scale = TRUE)$Ainv

```


# Meta-analysis for each hybrids and parental

```{r meta-analysis for each}

for (i in c("lnRR")) {
  for (j in c("withTS", "withoutTS")) {
    for (h in c("spL", "hybLS", "hybSL")) {
      
      # Make data for each cross
      split.data <- with.without.TS %>%
        # use observations which both crosses are availabe to compare the heterogeneity of both crosses
        filter(
          reciprocal == "Viable",
          cross == h,
          data.type == j
          )
      
      print(paste(j, i, "in", h))
      
      # Phylogenetic random meta-analysis
      phyl.random <- rma.mv(
        yi = split.data[, paste(i, "es", sep = ".")], 
        V = split.data[, paste(i, "sv", sep = ".")], 
        data = split.data, method = "REML",
        random = list(~1 | spL.name, ~1 | Study.ID, ~1 | Cross.ID, ~1 | ES.ID),
        R = list(spL.name = phylo_cor)
        )
      
      funnel(phyl.random)
      
      # creating summary table of results
      assign(
        paste("res", j, h, sep = "."), 
        cbind(
          phyl.random$beta,   # regression: estimate
          phyl.random$ci.lb,  # regression: 95ci 
          phyl.random$ci.ub,  # regression: 95ci
          phyl.random$pval,   # P
          length(split.data$ES.ID) # N
          ) %>%
          as.data.frame() %>%
          rename(estimate = V1, ci.lb = V2, ci.ub = V3, P = V4, N = V5) %>%
        mutate(
          # indicate cross name (spL, hybLS, hybSL)
          cross = h,
          # indicate dataset without TS
          data.type = j
          ) %>%
        mutate(metaunit =  str_c(data.type, cross, sep = "_"))
        )
      
      # Calculate I^2 for heterogeneity
      # http://www.metafor-project.org/doku.php/tips:i2_multilevel_multivariate
      W <- diag(1/split.data[, paste(i, "sv", sep = ".")])
      X <- model.matrix(phyl.random)
      P <- W - W %*% X %*% solve(t(X) %*% W %*% X) %*% t(X) %*% W
      I2 <- 100 * sum(phyl.random$sigma2) / (sum(phyl.random$sigma2) + (phyl.random$k-phyl.random$p)/sum(diag(P)))
      print(paste("I^2 =", I2))
      
    }
  }
    
  res.all.ma <-
    bind_rows(
      res.withTS.spL, res.withTS.hybLS, res.withTS.hybSL,
      res.withoutTS.spL, res.withoutTS.hybLS, res.withoutTS.hybSL  
      ) %>%
    as.data.frame()
  # %>%
  #   within(metaunit <-ordered(metaunit, c("withTS.spL", "withTS.hybLS", "withTS.hybSL", "withoutTS.spL", "withoutTS.hybLS", "withTS.hybSL")))

  # creating a forest plot
  plot.metamean <- ggplot(
    data = res.all.ma, 
    aes(x = tanh(estimate), y = metaunit)
    ) +
    scale_x_continuous(
      limits = c(-1, 1), 
      breaks = seq(-1, 1, by = 0.2)
      )+ 
    geom_quasirandom(
      data = with.without.TS, 
      aes(x = tanh(lnRR.es), y = metaunit, size = 1/lnRR.sv), 
      alpha = 0.2, groupOnX = FALSE
      ) + 
    geom_errorbarh(
      aes(xmin = tanh(ci.lb), xmax = tanh(ci.ub)), 
      height = 0, size = 0.5, alpha = 0.6
      ) + # CI
    geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) + # creating dots and different size (bee-swarm and bubbles)
    geom_point(size = 3, shape = 21, fill = "black") + 
    annotate("text", x = -0.93, y = res.all.ma$metaunit, label = paste("italic(N)==", res.all.ma$N), parse = TRUE, hjust = "left", 
    size = 3.5) + 
    ylab("") +
    theme_bw() +
    theme(
      legend.position = c(0, 1), 
      legend.justification = c(0, 1),
      legend.direction = "horizontal",
      legend.background = element_blank()
      )
  
  print(plot.metamean)
      

  ggsave(
    plot = plot.metamean + theme_classic(),
    file = paste("../Analysis/mean.general.metamean", i, "svg", sep = "."),
    height = 2.5, width = 2.3
  )
}

```


# Assessing dominance
Compare midparent and hybrids by comparing phenotypic difference from spS to midparent (spL+spS/2) and to hybrids.    
phenotypic difference from spS to midparent: *ln((spL+spS/2)/SS)*   
phenotypic difference from spS to hybrids: *ln(hyb/SS)*  
As the variance of *ln((spL+spS/2)/SS)*, we use the variance of *ln(LL/SS)* for simplicity

```{r assessing dominance}

# Calculate midparent 
midparent <- mean.dif %>%
  # Divide mean by 2 in spL whereas hybrids are constant
  mutate(
    lnRR.midparent.es = 
      ifelse(
        cross == "spL",
        log(((Mn.spL + Mn.spS)/2)/Mn.spS), lnRR.es
        )
    # Divide variance by 4 in spL whereas hybrids are constant
    ) %>%
  mutate_at("cross", as.factor) %>%
  within(levels(cross) <- c("hybLS", "hybSL", "midparent"))


################################################
# phylogenetic random regresson (ANOVA)
################################################
# Regress by lnRR of phenotypic difference between parentals 
midparent.random <- rma.mv(
  yi = lnRR.midparent.es, 
  V = lnRR.sv, 
  data = midparent, method = "REML",
  random = list(~1 | spL.name, ~1 | Study.ID, ~1 | Cross.ID),
  R = list(spL.name = phylo_cor),
  mods = ~ relevel(cross, ref = "midparent")
  )
  
summary(midparent.random)

print(paste("hybLS is larger than midparent in",
    round(
      (exp(midparent.random$beta[1]+midparent.random$beta[2]) -
         exp(midparent.random$beta[1])
       )*100,
      2),
    "percent"))
print(paste("hybSL is larger than midparent in",
    round(
      (exp(midparent.random$beta[1]+midparent.random$beta[3]) -
         exp(midparent.random$beta[1])
       )*100,
      2),
    "percent"))

```



# comparing mean across all crosses
Comparing the differences between parentals and hybrids

```{r comparing mean across all crosses}

for (i in c("lnRR")) {
  
  ################################################
  # phylogenetic random regresson (ANOVA)
  ################################################
    # Regress by lnRR of phenotypic difference between parentals 
    phyl.random.spL <- rma.mv(
      yi = mean.dif[, paste(i, "es", sep = ".")], 
      V = mean.dif[, paste(i, "sv", sep = ".")], 
      data = mean.dif, method = "REML",
      random = list(~1 | spL.name, ~1 | Study.ID, ~1 | Cross.ID),
      R = list(spL.name = phylo_cor),
      mods = ~ relevel(cross, ref = "spL")
      )
    
    phyl.random.hybLS <- rma.mv(
      yi = mean.dif[, paste(i, "es", sep = ".")], 
      V = mean.dif[, paste(i, "sv", sep = ".")], 
      data = mean.dif, method = "REML",
      random = list(~1 | spL.name, ~1 | Study.ID, ~1 | Cross.ID),
      R = list(spL.name = phylo_cor),
      mods = ~ cross
      )

  }
  
summary(phyl.random.spL)
# summary(phyl.random.hybLS)

```


# Assesing maternal inheritance
Comparing the differences between parentals and hybrids

```{r maternal vs paternal}


for (i in c("lnRR", "SMD")) {
  
  ################################################
  # phylogenetic random regresson (ANOVA)
  ################################################
  
  if (i == "lnRR") {
    # Regress by lnRR of phenotypic difference between parentals 
    phyl.random <- rma.mv(
      yi = hybrids[, paste(i, "es", sep = ".")], 
      V = hybrids[, paste(i, "sv", sep = ".")], 
      data = hybrids, method = "REML",
      random = list(~1 | spL.name, ~1 | Study.ID, ~1 | Cross.ID),
      R = list(spL.name = phylo_cor),
      mods = ~ trait.type + pheno.div.ratio + cross*hetero.sex
        # + cross*divergence.COI + cross*pheno.div.ratio
      )

  } else {
    # Regress by absolute value of phenotypic difference between parentals 
    phyl.random <- rma.mv(
      yi = hybrids[, paste(i, "es", sep = ".")], 
      V = hybrids[, paste(i, "sv", sep = ".")], 
      data = hybrids, method = "REML",
      random = list(~1 | spL.name, ~1 | Study.ID, ~1 | Cross.ID),
      R = list(spL.name = phylo_cor),
      mods = ~ cross*hetero.sex + divergence.COI + sq.divergence.COI + pheno.div.ratio
        # + cross*divergence.COI + cross*pheno.div.diff
      )
    
  }
  
  # print(summary(phyl.random))
  
  ################################################
  # Output result
  ################################################
  
  reg <- cbind(
    phyl.random$beta,   # regression: estimate
    phyl.random$ci.lb,  # regression: 95ci 
    phyl.random$ci.ub,  # regression: 95ci
    phyl.random$pval   # P
    ) %>%
    cbind(
      ., row.names(.)
    ) %>%
    as.data.frame() %>%
    rename(estimate = V1, ci.lb = V2, ci.ub = V3, P = V4, factors = V5) %>%
    mutate_all(as.character) %>%
    mutate_at(vars(estimate:P), as.numeric) %>%
    mutate_at(vars(factors), as.factor)

  # write.csv(
  #   reg, 
  #   paste("../Analysis/mean.general.result", i, "csv", sep = "."),
  #   quote = F, row.names = F
  #   )
  
  plot <- ggplot(reg, aes(y = estimate, x = factors)) +
    geom_rect(
      aes(ymin= -0.5, ymax= 0.5,xmin=-Inf,xmax=Inf),
      fill="Grey 95", inherit.aes = FALSE
      )+
    geom_errorbar(
      aes(ymin = ci.lb, ymax = ci.ub), 
      colour="black", width=.0001
      ) +
    geom_point(size=3, colour="black")+
    scale_shape_manual(values=c(17, 16)) +
    scale_x_discrete(limits = rev(reg$factors))+ # reverse x-axis
    geom_hline(yintercept = 0, linetype="dashed", size = 0.3) +
    coord_flip() +
    ylab(i) + xlab("") +
    mytheme
  
  print(plot)
  
  ggsave(
    plot = plot, 
    file = paste("../Analysis/mean.general.result", i, "svg", sep = "."), 
    height = 4.5, width = 4
    )

  print(
    reg %>%
      as.data.frame() %>%
      mutate_if(is.numeric, round, 3) %>%
      column_to_rownames("factors")
    )

}

```

