---
title: "Non-additive genetic effects induce novel phenotypic distributions in male mating traits of F1 hybrids"
author: "Keisuke Atsumi, Losia Lagisz & Shinichi Nakagawa"
date: '`r format(Sys.time(), "%y/%m/%d %H:%M")`'
output:
  html_document:
    code_download: true
    code_folding: hide
    theme: united # “default”, “cerulean”, “journal”, “flatly”, “darkly”, “readable”, “spacelab”, “united”, “cosmo”, “lumen”, “paper”, “sandstone”, “simplex”, “yeti”
    toc: yes
    toc_float: yes
subtitle: Supplementary Information

---
## Setup

### Load packages

```{r}

rm(list=ls())  # reset workspace
options(scipen=100)  # do not show numbers using exponential

# install & load packages
pacman::p_load(
  openxlsx   # open excel
  , tidyverse
  , magrittr   # extended pipe
  , metafor    # meta-analysis
  , MCMCglmm   # comparative analysis
  , orchaRd    # Orchard plot - meta-analysis
  , rotl       # open tree of life
  , ape        # Phylogeny
  , phytools   # Phylogeny
  , knitr  
  , kableExtra # nice tables
  , pander     # nice tables
  , svglite    # Export SVG plots
  , ggiraphExtra # Geom predict
  , ggbeeswarm # Orchard plot
  , ggtree
  , patchwork   # combine multiple plots
  # , R.rsp
)

# Rmarkdown settings
knitr::opts_chunk$set(
  prompt  = FALSE,  # Do not add > or + in inline-code
  message = FALSE, 
  comment = "", 
  warning = FALSE,  # Mute warnings
  tidy    = TRUE
  ) 
options(knitr.kable.NA = '') # Hide NAs in kable table
```


### Custom function
We have custom functions named : `get_pred()`, `get_reg()`, `get_fixed.MCMCglmm()` and  `get_random.MCMCglmm()`, all of which are used later (see below for their functionality) and the code are included here. 

```{r}

#' Title: get_pred
#' function to get prediction intervals (crediblity intervals) from rma objects (metafor)
#'
#' @param model: rma.mv object 
#' @param mod: the name of a moderator 
get_pred <- function(model, mod = " ") {
  I2 <- i2_ml(model) %>%
    as.data.frame() %>%
    rownames_to_column("Partition") %>%
    rename("I2" = ".") %>%
    mutate(percentage = str_c(round(I2*100,1),"%", sep = "")) %>%
    column_to_rownames("Partition")

  name <- as.factor(str_replace(row.names(model$beta), mod, ""))
  len <- length(name)
  
  if (len != 1) {
      newdata <- matrix(NA, ncol = len, nrow = len)
      for (i in 1:len) {
          # getting the position of unique case from X (design matrix)
          pos <- which(model$X[, i] == 1)[[1]]
          newdata[, i] <- model$X[pos, ]
      }
      pred <- predict.rma(model, newmods = newdata)
    } else {
        pred <- predict.rma(model)
    }

    table <- tibble(
      'Dataset' = "",
      'Fixed effects' = name, 
      'Estimate' = model$beta, # regression: estimate
      'LowerCI' = model$ci.lb, # regression: 95ci, 
      'UpperCI'  = model$ci.ub, # regression: 95ci
      'lowerPR' = pred$cr.lb,  # lower prediction range
      'upperPR' = pred$cr.ub, # lower prediction range
      'P'        = model$pval,
    # 'V[species with phylogeny]' =
    #   c(model$sigma2[1], rep("", length(model$beta))),
    # 'V[study]' =
    #   c(model$sigma2[2], rep("", length(model$beta))),
    # 'V[crossed strain]' =
    #   c(model$sigma2[3], rep("", length(model$beta))),
    # 'V[residual]' = 
    #   c(model$sigma2[4], rep("", length(model$beta))),
    'I2[total]' = 
      c(I2["I2_total","percentage"], rep("", length(model$beta)-1)),
    '%I2[species with phylogeny]' = 
      c(I2["I2_spL.name","percentage"], rep("", length(model$beta)-1)),
    '%I2[study]' =
      c(I2["I2_Study.ID","percentage"], rep("", length(model$beta)-1)),
    '%I2[crossed strain]' =
      c(I2["I2_Cross.ID","percentage"], rep("", length(model$beta)-1)),
    '%I2[residual]' = 
      c(I2["I2_ES.ID","percentage"], rep("", length(model$beta)-1)),
    )  %>%
    as.data.frame() %>%
    mutate_at(vars('Estimate':'P'), as.numeric) %>%
    mutate(significance = ifelse(P < 0.05, "*", ""))
}



#' Title: get_reg
#' function to get summary stats from rma objects (metafor)
#' @param model: rma.mv object 
#' @param mod: the name of a moderator 
get_reg <- function(model, mod = " ") {
  
  I2 <- i2_ml(model) %>%
    as.data.frame() %>%
    rownames_to_column("Partition") %>%
    rename("I2" = ".") %>%
    mutate(percentage = str_c(round(I2*100,1),"%", sep = "")) %>%
    column_to_rownames("Partition")
  
  table <- tibble(
    'Dataset' = "",
    'Fixed effects' = c("", row.names(model$beta)),
    'Estimate' = c("", model$beta), # regression: estimate
    'LowerCI' = c("", model$ci.lb), # regression: 95ci, 
    'UpperCI'  = c("", model$ci.ub), # regression: 95ci
    'P'        = c("", model$pval),
    # 'V[species with phylogeny]' =
    #   c(model$sigma2[1], rep("", length(model$beta))),
    # 'V[study]' =
    #   c(model$sigma2[2], rep("", length(model$beta))),
    # 'V[crossed strain]' =
    #   c(model$sigma2[3], rep("", length(model$beta))),
    # 'V[residual]' = 
    #   c(model$sigma2[4], rep("", length(model$beta))),
    'I2[total]' = 
      c(I2["I2_total","percentage"], rep("", length(model$beta))),
    '%I2[species with phylogeny]' = 
      c(I2["I2_spL.name","percentage"], rep("", length(model$beta))),
    '%I2[study]' =
      c(I2["I2_Study.ID","percentage"], rep("", length(model$beta))),
    '%I2[crossed strain]' =
      c(I2["I2_Cross.ID","percentage"], rep("", length(model$beta))),
    '%I2[residual]' = 
      c(I2["I2_ES.ID","percentage"], rep("", length(model$beta))),
    )  %>%
    as.data.frame() %>%
    mutate_at(vars('Estimate':'P'), as.numeric) %>%
    mutate(significance = ifelse(P < 0.05, "*", ""))
}


#' Title: get_random.MCMCglmm
#' 
#' @param x: VCV of MCMCglmm products (i.e. summary('MCMCglmm object'$VCV)), which was transformed if apprecable. 
get_random.MCMCglmm <- function(x) {
  
  bind_cols(
    x$statistics %>%
    as.data.frame,
    x$quantiles %>%
    as.data.frame
    )  %>% 
    rownames_to_column("Random effects")  %>% 
    rename("Estimates" = "Mean") %>%
    as.data.frame %>%
    mutate(
      '95% credible interval' = str_c(
        round(.[,"2.5%"],2), round(.[,"97.5%"],2),
        sep = "--" # en-dash
        )
      ) %>%
    dplyr::select("Random effects", "Estimates", "95% credible interval") 
  
}

#' Title: get_fixed.MCMCglmm
#' 
#' @param x: Solution of MCMCglmm products (i.e. summary('MCMCglmm object'$solutions)), which was transformed if apprecable. 
get_fixed.MCMCglmm <- function(x) {
  
  x %>%
    as.data.frame() %>%
    rownames_to_column(var = "Factors") %>%
    mutate(
      '95% credible interval' = str_c(
        round(.[,"l-95% CI"],2), round(.[,"u-95% CI"],2),
        sep = " -- " # en-dash
        ),
      Estimates = round(post.mean, 2),
      P = round(pMCMC, 3)
      ) %>%
    mutate(significance = ifelse(P < 0.05, "*", "")) %>%
    mutate(
      "Description" = 
        str_c("$\\beta$ = ", Estimates,
              ", CI = ", .[, "95% credible interval"],
              ", P = ", round(P, 3),
              "")
      )

}
  
#++++++++++++++++++++++++++++++++++++++++++++++#
# Setting plot theme for forest plots
#++++++++++++++++++++++++++++++++++++++++++++++#
foresttheme <- theme_bw() +
  theme(
    legend.position = "none",
    axis.line = element_line(size = 0.4, color = "grey50"),
    axis.ticks = element_line(size = 0.3, color = "grey50"),
    axis.text = element_text(size = 9.5, color = "black"),
    panel.grid.major.y = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    strip.text = element_text(size = 9.5, color = "black")
    )

#++++++++++++++++++++++++++++++++++++++++++++++#
# Setting plot theme for forest plots
#++++++++++++++++++++++++++++++++++++++++++++++#
stackedbartheme <- theme(
    strip.text = element_text(size = 13),
    axis.text.y = element_text(size = 13),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    axis.ticks.x = element_blank(),
    legend.text = element_text(size = 11),
    legend.background = element_rect("grey95")
  )

#++++++++++++++++++++++++++++++++++++++++++++++#
# Setting plot theme for regression scatterplot
#++++++++++++++++++++++++++++++++++++++++++++++#
regressiontheme <-   theme_bw() +
    theme(
      legend.position = "none",
      axis.ticks = element_line(size = 0.3, color = "grey50"),
      axis.text = element_text(size = 9.5, color = "black"),
      axis.text.y = element_blank(),
      panel.grid.major.y = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_rect(colour = "grey50", size = 0.7),
      strip.text = element_text(size = 9.5, color = "black")
      )

#++++++++++++++++++++++++++++++++++++++++++++++#
# Setting plot theme for orchard plot
#++++++++++++++++++++++++++++++++++++++++++++++#
orchardtheme <-  theme_bw() +
  theme(
    panel.grid.major.y = element_blank(),
    axis.text.y = element_text(size = 14, color = "black", face = "italic"),
    axis.text.x = element_text(size = 14, color = "grey20"),
    axis.title = element_text(size = 14, color = "black"),
    legend.position = c(0.15, 0.002),
    legend.justification = c(0.15, 0.002),
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 14),
    legend.direction = "horizontal"
    )

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
# Correcting estimate of binomial regression
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
c2 <- (16 * sqrt(3)/(15 * pi))^2

```

<div style="margin-bottom:180px;">
</div>

# Data description
<div style="margin-bottom:70px;">
</div>

List of primary studies included

```{r, results = 'asis'}

read.xlsx(
  "../data/original.data.xlsx", sheet = "Primary.studies"
  # Same data is also saved as "../data/original.data.Primary.studies.txt"
  ) %>%
  arrange(First.author, Year) %>%
  kable("html") %>% kable_styling("striped", position = "left") %>% 
  scroll_box(width = "100%", height = "500px")
  
```

**Study.name**: Including author name(s) and published year

<div style="margin-bottom:70px;">
</div>

## Table of the dataset

The phenotypic dataset of this study.

```{r, results = 'asis'}

## Phenotype data ##
pheno <- read.xlsx(
    "../data/original.data.xlsx", sheet = "Phenotype"
    # Same data is also saved as "../data/original.data.Phenotype.txt"
    ) %>%
  # Excluding data without any parent data
  drop_na(contains("SD.sp")) %>%
  # to numeric
  mutate_at(
    vars(contains("Mn") | contains("SD") | N.sp1:N.sp2), 
    as.numeric
    ) %>%
  # delete observation with negative mean trait value
  filter(Mn.sp1 > 0 & Mn.sp2 > 0 & homologous == "Yes") %>%   
  # calculate phenotypic difference between parental species
  mutate(
    Pheno.divergence = abs(log(Mn.sp1/Mn.sp2))
    ) %>%
  mutate_at(vars(contains("pheno.div")), scale) %>%
  # describe whether full cross or not
  mutate(
    Reciprocal = ifelse(
      is.na(Mn.hyb12 & Mn.hyb21), 
      "Inviable", "Viable"
      )
    )

# making a scrollable table
kable(pheno, "html") %>% kable_styling("striped", position = "left") %>% 
    scroll_box(width = "100%", height = "500px")

```

**Study.ID**: ID of studies

**Study.name**: Including author name(s) and published year

**Source**: Source of phenotypc data in the primary studes

**Cross.ID**: Parental species used in the crossing expreiments. Distinguishes intraspecific populations.

**Gennus**: Studied genus

**sp1.name** and **sp2.name**: Crossed species. Ordered alphabetically.

**species.pair**: Parental species used in the crossing expreiments. Not distinguish intraspecific populations.

**homologous**: Measured traits are homologous across all crosses. If not, data has been excluded

**trait.type**: Sound or Morphology. Used in regressions bellow as a moderator.

**trait**: Trait name described in primary studies

**Mn.~**: Phenotypic mean of each cross

**SD.~**: SD of phenotype in each cross

**SE.~**: SE of phenotype in each cross

**Parents.~**: Number of parents used in each crossing. Usually not provided by the primary studies.

**N.~**: Number of individuals whose phenotype was measured

**reps.~**: Number of measurements, if replicated (especially in behavioral traits). Not used in the analyses bellow.

**Pheno.divergence**: Phenotypic divergence between parents in the focal trait, which is calculated as absolute value of log response ratio (lnRR) of phenotypic means. Used in regressions bellow as a moderator.

<div style="margin-bottom:70px;">
</div>


The species-level moderator dataset of this study.

```{r, results = 'asis'}

meta <- read.xlsx(
    "../data/original.data.xlsx", sheet = "Species.level.moderators"
    # Same data is also saved as "../data/original.data.Species.level.moderators.txt"
    ) %>%
  mutate_at(vars(contains("divergence")), as.numeric) %>%
  # Logalize genetic divergence
  mutate_at(vars(contains("divergence")), log10)

# making a scrollable table
kable(meta, "html") %>% kable_styling("striped", position = "left") %>% 
    scroll_box(width = "100%", height = "500px")
  

#++++++++++++++++++++++++++++++++++++++++++++++
# Combine phenotypic data and moderators data
#++++++++++++++++++++++++++++++++++++++++++++++
original.dat <- left_join(pheno, meta)
# add unique ID for each effect size (row)
original.dat$ES.ID <- paste("ES", sprintf("%03d",c(1:dim(original.dat)[1])), sep="")

# #+++++++++++++++++++++++++++++++++
# print("Scaling")
# #+++++++++++++++++++++++++++++++++
# print("Phenotypic divergence ratio")
# attributes(pheno$Pheno.divergence)
# print("Minimum scaled value")
# min(pheno$Pheno.divergence)
# print("Maximum scaled value")
# max(pheno$Pheno.divergence)

```

**Reciprocal**: Viability of reciprocal hybrids, with two levels - *Viable* or *Inviable*

**Genet.divergence**: Natural logarithm of genetic distance at mtDNA COI region (>450bp).

**Distribution**: Distribution overlap - *Allopatry* or *Overlap*

**Hetero.sex**: Heterogametic sex - *Female* (ZW and Z0) or *Male* (XY and X0)


<div style="margin-bottom:70px;">
</div>
## Species composition
```{r, results = 'asis'}

#+++++++++++++++++++++#
# Phylogeny
#+++++++++++++++++++++#

# species pairs data 
taxa <- meta %>%
  select(-Cross.ID) %>%
  distinct_all(.keep_all = TRUE) %>%
  mutate_at("taxa", as.factor)

# matching names from open tree taxonomy
order <- tnrs_match_names(
  names = levels(taxa$taxa) %>%
    str_replace_all("_", " "), 
  context_name = "Animals"
  )

# which names return more than 1 match?
multimatch <- order$ott_id[order$number_matches != 1]
# inspect(order, ott_id = multimatch[1]) # Anura, confirmed adopted ott_id is correct
# inspect(order, ott_id = multimatch[2]) # Neuroptera, confirmed adopted ott_id is correct

# Create taxonomic tree
tree <- tol_induced_subtree(ott_ids = order$ott_id)
# Remove ott ids from tip label
tree$tip.label %<>%
  strip_ott_ids(remove_underscores=TRUE)
tree$tip.label[8] <- "Anura"

# # N of species pairs at each order
# factor(meta.sum$taxa, levels = as.vector(tree$tip.label))

plot.phylo <- ggtree(tree) + 
  geom_tiplab(
    geom = "image",
    image = paste("../data/pic", tree$tip.label, "png", sep = "."), 
    size = 0.1, offset = 3, hjust = 1
    ) +
  geom_tiplab(
    geom = "text",  
    label = tree$tip.label, 
    align = 1, size = 3
    ) +
  xlim(NA, 7)

# images from phylopic #    
# Lepidoptera (genus Catocala) "c224abfd-ee39-4923-98e5-c2606dcc56cb", 
# Diptera (Drosophila) "0cd6cc9f-683c-470e-a4a6-3b68beb826fa"
# Orthoptera (cricket) "b80d830b-155a-4ca5-9119-9a9fde019cc6"
# Rodentia (mouse), drawn by David Liao "0f6af3d8-49d2-4d75-8edf-08598387afde"
# Aves (Quail) "42f85a2b-7517-439a-8dc3-b745a35c035d"
# Anura (genus Hyla) "A22D353D-B045-4044-9432-8F340B9A3104", 
# Cichliformes (Nile tilapia), drawn by Milton Tan "84c7e672-2593-44a6-a807-cffbd3156cc5" 


#+++++++++++++++++++++#
# Summary 
#+++++++++++++++++++++#

summary <- original.dat %>%
  group_by(taxa) %>%
  summarise(
    'Species pair' = length(unique(species.pair)),
    'Obser- vation' = length(unique(ES.ID)),
    Study = length(unique(Study.ID))
    ) %>%
  # Order taxon so that match with phylogenetic tree topology
  within(taxa <- ordered(taxa, levels = c("Neuroptera", "Coleoptera", "Diptera", "Lepidoptera", "Orthoptera", "Aves", "Rodentia", "Anura", "Cichliformes")))


### Table ###
summary %>%
  summarise_if(is.numeric, sum) %>%
    mutate(taxa = "Total") %>%
  bind_rows(summary, .) %>%
  kable("html", digits = 3) %>% 
  kable_styling("striped", position = "left")

### Plot ###
plot.sum <- ggplot(
  # Make tidy summary data
  summary %>%
  gather(key = metrics, value = N, -c(taxa)) %>%
  # Order metrics
  within(
    metrics <- ordered(
      metrics,
      levels = c("Study", "Species pair", "Obser- vation")
      )
    ), 
  aes(x = "", y = N, fill = taxa)) +
  geom_bar(width = 1, stat = "identity") +
  scale_fill_brewer(palette = "YlGn") +
  facet_wrap(
    scale = "free", "metrics",
    # strip text into two lines
    labeller = label_wrap_gen(width = 8)
    ) +
  xlab("") +
  stackedbartheme +
  theme(
    strip.text = element_text(size = 15),
    axis.text.y = element_text(size = 14)
    )

#+++++++++++++++++#
# Combine figures
#+++++++++++++++++#
plot.all <- plot.phylo + plot.sum
plot.all
# ggsave(
#   plot = plot.all, 
#   file = "../Analysis/data.svg", height = 5, width = 8.5
#   )

```
**Figure 1a** 

<div style="margin-bottom:70px;">
</div>

## Taxonomic distribution of species-level moderator status
Summarised distributions of categorical species-level moderators in each taxon (order).
```{r, results='asis'}

metavars <- c("Reciprocal", "Distribution", "Hetero.sex")

meta.unique <- original.dat %>%
  distinct_at("species.pair", .keep_all = TRUE) %>%
  mutate_at(metavars, as.factor)

meta.all.sp <- meta.unique %>% 
  group_by(taxa) %>%
  summarise(Total = length(species.pair)) 

for (i in metavars) {
  
  bind_rows(
    # At each taxon
    meta.unique %>% 
      group_by_("taxa", i) %>%
      summarise(species = length(species.pair))
    ,
    # All taxon
    meta.unique %>% 
      group_by_(i) %>%
      summarise(species = length(unique(species.pair))) %>% 
      mutate(taxa = "Total")
    ) %>%
    ungroup %>%
    spread(key = i, value = "species") %>%
    mutate_all(~replace(., is.na(.), 0)) %>% # replace NA by 0
    as.data.frame %>%
    # All species pair at each taxon: summing columns
    mutate(Total = rowSums(.[2:(1+nlevels(meta.unique[, i]))])) %>%
    # Calc % of level 2 (i.e. male hetero, ...)
    mutate('%' = round(.[3]/Total*100, 1)) %>%
    rename(!!paste0(levels(meta.unique[, i])[2], "%") := "%") %>%
    # Table output
    kable("html", digits = 3, caption = i) %>% 
    kable_styling("striped", position = "left") %>%
    print()

}  

```

<div style="margin-bottom:70px;">
</div>

## Data used in meta-regression (all metadata available)
```{r}

full_join(
  # All species pair
  original.dat %>%
    select(c("taxa", "species.pair")) %>%
    distinct_all() %>%
    group_by(taxa) %>%
    summarise('All species' = length(species.pair)),
  # Species pair used in meta-regression
  original.dat %>%
    filter(!is.na(sex.determination), !is.na(Genet.divergence)) %>%
    select(c("taxa", "species.pair")) %>%
    distinct_all() %>%
    group_by(taxa) %>%
    summarise('Metadata available' = length(species.pair))
  ) %>%
  mutate_all(~replace(., is.na(.), 0)) %>% # replace NA by 0
  kable("html", caption = "Numbers of all species pairs, and species pairs used in meta-regression
") %>% 
  kable_styling("striped", position = "left")

```

<div style="margin-bottom:70px;">
</div>

## Data processing

### Allign parental species according to trait values

Currently, dataset is composed of <br>   
'species 1' and 'species 2', ordered alphabetically, and 'hybrid12' (sp1 mother & sp2 father) and 'hybrid 21' (sp2 mother & sp1 father)<br>
<br>
To investigate paternal effect in hybrids using difference in mean trait value between reciprocal cross, it's better to allign species with larger trait value (<i>spLL<sub>M</sub></i>) and smaller value (<i>spSS<sub>M</sub></i>) in each traits. Name of hybrids will be changed according to change in names of parental species (<i>hybridLS<sub>M</sub></i> & <i>hybridSL<sub>M</sub></i>).  <br>

```{r}

#+++++++++++++++++++++++++++++++++++++++++++++++++#
# sp1 >= sp2 in phenotypic mean 
#+++++++++++++++++++++++++++++++++++++++++++++++++#
# extract
sp1sp2.mean <- original.dat %>%
  filter(Mn.sp1 >= Mn.sp2) # filtering according to mean trait value of parentals
# change column name from sp1 or sp2 -> spL or spS
names(sp1sp2.mean) <- gsub("1", "L", names(sp1sp2.mean))
names(sp1sp2.mean) <- gsub("2", "S", names(sp1sp2.mean))

#+++++++++++++++++++++++++++++++++++++++++++++++++#
# sp1 < sp2 in phenotypic mean 
#+++++++++++++++++++++++++++++++++++++++++++++++++#
# extract
sp2sp1.mean <- original.dat %>%
  filter(Mn.sp1 < Mn.sp2)
# change column name from sp1 or sp2 -> spS or spL
names(sp2sp1.mean) <- gsub("1", "S", names(sp2sp1.mean))
names(sp2sp1.mean) <- gsub("2", "L", names(sp2sp1.mean))

#+++++++++++++++++++++++++++++++++++++++++++++++++#
# combine dataset & sort by ES.ID 
#+++++++++++++++++++++++++++++++++++++++++++++++++#
bind_rows(sp1sp2.mean, sp2sp1.mean) %>%
  arrange(ES.ID) %>%
  write.csv("../data/dat.mean.csv", quote=F,row.names = F)

```
Data set created here, `dat.mean.csv`, is used in calculating effect sizes for  analyses investigating [phenotypic mean](#meta-analysis-for-phenotypic-mean) and [novel phenotype expression](#novel-phenotype-expression).


### Allign parental species according to phenotypic variation (CV)

To investigate paternal effect in hybrids using difference in coefficient of variation (CV) between reciprocal cross, it's better to allign species with larger CV (<i>spLL<sub>V</sub></i>) and smaller CV (<i>spSS<sub>V</sub></i>) in each traits. Name of hybrids will be changed according to change in names of parental species (<i>hybridLS<sub>V</sub></i> & <i>hybridSL<sub>V</sub></i>).  

```{r}

#+++++++++++++++++++++++++++++++++++++++++++++++++#
# sp1 >= sp2 in phenotypic variation (CV)
#+++++++++++++++++++++++++++++++++++++++++++++++++#
# extract
sp1sp2.var <- original.dat %>%
  filter(SD.sp1/Mn.sp1 >= SD.sp2/Mn.sp2) # filtering according to CV of parentals
# change column name from sp1 or sp2 -> spL or spS
names(sp1sp2.var) <- gsub("1", "L", names(sp1sp2.var))
names(sp1sp2.var) <- gsub("2", "S", names(sp1sp2.var))

#+++++++++++++++++++++++++++++++++++++++++++++++++#
# sp1 < sp2 in phenotypic variation (CV)
#+++++++++++++++++++++++++++++++++++++++++++++++++#
# extract
sp2sp1.var <- original.dat %>%
  filter(SD.sp1/Mn.sp1 < SD.sp2/Mn.sp2)
# change column name from sp1 or sp2 -> spS or spL
names(sp2sp1.var) <- gsub("1", "S", names(sp2sp1.var))
names(sp2sp1.var) <- gsub("2", "L", names(sp2sp1.var))

#+++++++++++++++++++++++++++++++++++++++++++++++++#
# combine dataset & sort by ES.ID 
#+++++++++++++++++++++++++++++++++++++++++++++++++#
bind_rows(sp1sp2.var, sp2sp1.var) %>%
  arrange(ES.ID) %>%
  write.csv("../data/dat.CV.csv", quote=F,row.names = F)

```
Data set created here, `dat.CV.csv`, is used in calculating effect sizes for analyses investigating [phenotypic variation](#meta-analysis-for-phenotypic-variation) and [novel variability expression](#novel-variability-expression).


### Simultaneously judge novel phenotype and variability expression
We categorised phenotypic novelty (novel or non-novel) and relative phenotypic variability compared to parents (smaller, intermediate, larger) at each trait. 

```{r}

bind_rows(
  # Assess novel phenotype & variability expression in hyb12
  original.dat %>%
    drop_na(Mn.hyb12, SD.hyb12) %>%
    mutate(
      cross = "1x2",
      # Relative trait size
      relative.mean = ifelse(
        # Exceeding upper range
        Mn.hyb12 > Mn.sp1 & Mn.hyb12 > Mn.sp2,
        "Larger",
        ifelse(
          # Exceeding lower range
          Mn.hyb12 < Mn.sp1 & Mn.hyb12 < Mn.sp2,
          "Smaller",
          "Intermediate"
        )
      ),
      # Relative variability size
      relative.var = ifelse(
        # Exceeding upper range: 1
        SD.hyb12/Mn.hyb12 > SD.sp1/Mn.sp1 & 
          SD.hyb12/Mn.hyb12 > SD.sp2/Mn.sp2,
        "Larger",
        ifelse(
          # Exceeding lower range: "Smaller"
          SD.hyb12/Mn.hyb12 < SD.sp1/Mn.sp1 & 
            SD.hyb12/Mn.hyb12 < SD.sp2/Mn.sp2,
          "Smaller",
          "Intermediate"
        )
      )    
    ),
  # Assess novel phenotype & variability expression in hyb12
  original.dat %>%
    drop_na(Mn.hyb21, SD.hyb21) %>%
    mutate(
      cross = "2x1",
      # Relative trait size
      relative.mean = ifelse(
        # Exceeding upper range: 1
        Mn.hyb21 > Mn.sp1 & Mn.hyb21 > Mn.sp2,
        "Larger",
        ifelse(
          # Exceeding lower range: "Smaller"
          Mn.hyb21 < Mn.sp1 & Mn.hyb21 < Mn.sp2,
          "Smaller",
          "Intermediate"
        ) 
      ) ,
      # Relative variability size
      relative.var = ifelse(
        # Exceeding upper range: 1
        SD.hyb21/Mn.hyb21 > SD.sp1/Mn.sp1 & 
          SD.hyb21/Mn.hyb21 > SD.sp2/Mn.sp2,
        "Larger",
        ifelse(
          # Exceeding lower range: "Smaller"
          SD.hyb21/Mn.hyb21 < SD.sp1/Mn.sp1 & 
            SD.hyb21/Mn.hyb21 < SD.sp2/Mn.sp2,
          "Smaller",
          "Intermediate"
        )
      )    
    ) 
  ) %>%
  mutate(mean.novelty = ifelse(relative.mean == "Intermediate", "Nonnovel", "Novel")) %>%
  write.csv("../data/dat.novelty.csv", quote=F,row.names = F)

```
Data set created here, `dat.novelty.csv`, is used in investigating [phenotypic variability of novel phenotype](#phenotypic-variability-of-novel-phenotype).



<div style="margin-bottom:180px;">
</div>
# Meta-analysis for phenotypic mean

## Calculating effect sizes

To quantify phenotypic difference from <i>spSS<sub>M</sub></i> to the other crosses, we calculated log response ratio (lnRR) from phenotypic mean of <i>spSS<sub>M</sub></i> to those of the other crosses (<i>hybLS<sub>M</sub></i>, <i>hybSL<sub>M</sub></i> and <i>spLL<sub>M</sub></i>).<br>
Effecct size was calculated by using `escalc` function in `metafor` package 

```{r}

# load phenotypic data
dat <- read.csv("../data/dat.mean.csv", head = TRUE)

# Order by taxon
dat$taxa <- ordered(
  dat$taxa,
  levels = c("Neuroptera", "Coleoptera", "Diptera", "Lepidoptera", "Orthoptera", "Aves", "Rodentia", "Anura", "Cichliformes")
  )

### Difference between hybrids and smaller species (spS) ###

for (i in c("hybLS", "hybSL", "spL")) { # identify type of hybrids
  for (h in c("spS")) { # identify type of parentals
    assign(
      paste(i, h, sep = "_"),
      
      left_join(
        ### lnRR ###
        escalc(
          measure = "ROM",
          # N of hybrids
          n1i = dat[, paste("N", i, sep = ".")],
          # N of parentals
          n2i = dat[, paste("N", h, sep = ".")],
          # Mean of hybrids
          m1i = dat[, paste("Mn", i, sep = ".")],
          # Mean of parentals
          m2i = dat[, paste("Mn", h, sep = ".")],
          # SD of hybrids
          sd1i = dat[, paste("SD", i, sep = ".")],
          # SD of parentals
          sd2i = dat[, paste("SD", h, sep = ".")],
          data = dat
          ) %>%
          rename(lnRR.es = yi, lnRR.sv = vi),
        ### SMD ###
        escalc(
          measure = "SMD",
          # N of hybrids
          n1i = dat[, paste("N", i, sep = ".")],
          # N of parentals
          n2i = dat[, paste("N", h, sep = ".")],
          # Mean of hybrids
          m1i = dat[, paste("Mn", i, sep = ".")],
          # Mean of parentals
          m2i = dat[, paste("Mn", h, sep = ".")],
          # SD of hybrids]
          sd1i = dat[, paste("SD", i, sep = ".")],
          # SD of parentals
          sd2i = dat[, paste("SD", h, sep = ".")],
          data = dat
          ) %>%
          rename(SMD.es = yi, SMD.sv = vi)
        ) %>%
        
        select(ES.ID, contains("lnRR"), contains("SMD")) %>%
        # indicate type of hybrid
        mutate(cross = i) 
    )
  }
}

mean.dif <- bind_rows(
  hybLS_spS, hybSL_spS, spL_spS
  ) %>%
  drop_na(SMD.sv) %>%
  arrange(ES.ID) %>%
  left_join(., dat) 

# Dataset able to compare reciprocal crosses
write.csv(
  mean.dif %>%
    filter(Reciprocal == "Viable"), 
  "../data/mean.ES.general.csv", row.names = F
  )

```


### Funnel plots

```{r}

res <- rma(
  yi = lnRR.es, vi = lnRR.sv, 
  data = mean.dif, method="FE"
  )

### set up 2x2 array for plotting
par(mfrow=c(2,2))
 
### draw funnel plots
funnel(res, main="Standard Error", xlim = c(-2, 4))
funnel(res, yaxis="vi", main="Sampling Variance", xlim = c(-2, 4))
funnel(res, yaxis="seinv", main="Inverse Standard Error", xlim = c(-2, 4))
funnel(res, yaxis="vinv", main="Inverse Sampling Variance", xlim = c(-2, 4))

```

### Check data
Checked effect sizes with extremely high/low standard error (SE > 1.2 | 1/SE > 140) and confirmed that those data were correctly imported. 

```{r, results='asis'}

outliers <- mean.dif %>%
  # vi (sampling variance) 
  mutate(SE = sqrt(lnRR.sv)) %>%
  arrange(desc(SE)) %>%
  filter(SE > 1.2 | 1/SE > 140) %>%
  select(ES.ID, Study.name, SE, cross, Reciprocal, trait, Cross.ID) %>%
  mutate_if(is.numeric, round, 3)

outliers %>%
  kable("html", digits = 3, caption = "Effect sizes with extremely high/low standard error (SE > 1.2 | 1/SE > 140)") %>% 
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

```

Because those outliers did not affect meta-analytic model convergence, we did not exclude those data.
<div style="margin-bottom:70px;">
</div>

### Judging novel phenotype expression 

```{r}

# load spLS files
dat <- read.csv("../data/dat.mean.csv", head = TRUE)

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++#
# Difference between larger species (spL) and hybrids 
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++#

for (i in c("spL")) { # identify type of hybrids
  for (h in c("hybLS", "hybSL")) { # identify type of parentals
    assign(
      paste(h, i, sep = "_"),
        ### lnRR ###
        escalc(
          measure = "ROM",
          # N of hybrids
          n1i = dat[, paste("N", i, sep = ".")],
          # N of parentals
          n2i = dat[, paste("N", h, sep = ".")],
          # Mean of hybrids
          m1i = dat[, paste("Mn", i, sep = ".")],
          # Mean of parentals
          m2i = dat[, paste("Mn", h, sep = ".")],
          # SD of hybrids
          sd1i = dat[, paste("SD", i, sep = ".")],
          # SD of parentals
          sd2i = dat[, paste("SD", h, sep = ".")],
          data = dat
          ) %>%
        rename(lnRR.es = yi, lnRR.sv = vi) %>%
        select(ES.ID, contains("lnRR")) %>%
        mutate(
          # direction of transgressve segregation - greater than parent
          direction = "+",
          # SE for logistic distribution, for the weighted binomial regression
          # SE = pi/sqrt(3*(n_e + n_c))
          SE = pi/sqrt(3*(
            dat[, paste("N", i, sep = ".")] + dat[, paste("N", h, sep = ".")]
          ))
        )
    )
  }
}

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++#
# Difference between hybrids and smaller species (spS)
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++#

for (i in c("hybLS", "hybSL")) { # identify type of hybrids
  for (h in c("spS")) { # identify type of parentals
    assign(
      paste(i, h, sep = "_"),
        ### lnRR ###
        escalc(
          measure = "ROM",
          # N of hybrids
          n1i = dat[, paste("N", i, sep = ".")],
          # N of parentals
          n2i = dat[, paste("N", h, sep = ".")],
          # Mean of hybrids
          m1i = dat[, paste("Mn", i, sep = ".")],
          # Mean of parentals
          m2i = dat[, paste("Mn", h, sep = ".")],
          # SD of hybrids
          sd1i = dat[, paste("SD", i, sep = ".")],
          # SD of parentals
          sd2i = dat[, paste("SD", h, sep = ".")],
          data = dat
          ) %>%
          rename(lnRR.es = yi, lnRR.sv = vi) %>%
        select(ES.ID, contains("lnRR")) %>%
        mutate(
          # direction of transgressve segregation - smaller than parent
          direction = "-",
          # SE for logistic distribution, for the weighted binomial regression
          # SE = pi/sqrt(3*(n_e + n_c))
          SE = pi/sqrt(3*(
            dat[, paste("N", i, sep = ".")] + dat[, paste("N", h, sep = ".")]
          ))
        )
    )
  }
}

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++#
# Data output
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++#

bind_rows(
  ### Difference with mother species ###
  bind_rows(hybLS_spL, hybSL_spS) %>%
    mutate(parental = "Mother"),
  ### Difference with father species ###
  bind_rows(hybLS_spS, hybSL_spL) %>%
    mutate(parental = "Father")
  ) %>%
  drop_na(lnRR.sv) %>%
  left_join(., dat) %>%
  # Assign novel phenotype to 1, non-novel phenotype to 0 for each effect size
  mutate(Novelty = ifelse(lnRR.es < 0, 1, 0)) %>%
  ### Join with metadata ###
  left_join(
    ., read.xlsx("../data/original.data.xlsx", sheet = "Species.level.moderators")
    ) %>%
  mutate_at(vars(contains("divergence")), as.numeric) %>%
  mutate_at(vars(contains("divergence")), scale) %>%
  as.data.frame %>%
  select(-trait) %>%
  mutate_at("taxa", as.factor) %>%
  within(levels(Novelty) <- c("No", "Novel phenotype expression")) %>%
  within(
    taxa <- ordered(
      taxa,
      levels = c("Neuroptera", "Coleoptera", "Diptera", "Lepidoptera", "Orthoptera", "Aves", "Rodentia", "Anura", "Cichliformes")
      )
    ) %>%
  # Remove rows without any metadata
  drop_na(Hetero.sex, Pheno.divergence, trait.type, Genet.divergence) %>%
  # Insect or no
  mutate(
    insect = ifelse(taxa %in% c("Aves", "Rodentia", "Anura", "Cichliformes"), "no", "insect"),
  ) %>%
  write.csv("../data/mean.ES.Novelty.csv", row.names = F)

```


### Reload data & Prepare phylogenetic tree

```{r, fig.height = 6.5}

# Load effect sizes
mean.dif <- read.csv("../data/mean.ES.general.csv", head = TRUE) %>%
  # indicate dataset including novel phenotype
  mutate(data.type = "Alltraits")

# All trait observation irrespective of phenotypic novelty
All <- read.csv("../data/mean.ES.Novelty.csv", head = TRUE) %>%
  filter(lnRR.es < 0) %>%
  distinct(ES.ID)

# Trait observation of non-novel phenotypes
Nonovel <- read.csv("../data/mean.ES.general.csv", head = TRUE) %>%
  filter(!(ES.ID %in% All$ES.ID)) %>%
  # indicate dataset without novel phenotype
  mutate(data.type = "Nonnoveltraits")

# combine dataset with/without novel phenotype
Novel.Nonnovel <- bind_rows(mean.dif, Nonovel) %>%
  mutate(metaunit =  str_c(data.type, cross, sep = "_"))%>%
  # Use observations with both reciprocal crosses
  drop_na(contains("Mn"), contains("SD")) %>%
  # Insect or no
  mutate(
    insect = ifelse(taxa %in% c("Cichliformes", "Anura", "Aves", "Rodentia"), "no", "insect"),
  )


#+++++++++++++++++++++++++++++++++++++++++++++++#
# Phylogeny
#+++++++++++++++++++++++++++++++++++++++++++++++#

# # matching names from open tree taxonomy
# taxa <- tnrs_match_names(
#   names = levels(mean.dif$spL.name) %>%
#     str_replace_all("_", " "), 
#   context_name = "Animals"
#   )
# 
# # which names return more than 1 match?
# inspect(taxa, ott_id = taxa$ott_id[taxa$number_matches != 1])
# 
# # fixing names with more than 1 match
# taxa[taxa$number_matches != 1, ] <- 
#   inspect(taxa, ott_id = taxa$ott_id[taxa$number_matches != 1])[1, ]
# 
# tree <- tol_induced_subtree(ott_ids = taxa$ott_id)
# tree$tip.label %<>%
#   strip_ott_ids(remove_underscores=TRUE)
# 
# print("Original tree from OTL")
# plot(tree, no.margin=TRUE)
# 
# # randomly solve non-binary phylogeny
# set.seed(6)
# bin.tree <- multi2di(tree, random = T) 
# print("Randomly solved phylogeny")
# plot(bin.tree)
# 
# # correlation matrix to fit to the model
# bin.tree$tip.label <- bin.tree$tip.label %>%
#   as.factor() 
# 
# levels(bin.tree$tip.label) <- levels(mean.dif$spL.name) # making sure names match
# bin.tree$tip.label <- as.character(bin.tree$tip.label) # converting names back to character
# 
# write.tree(bin.tree, file= "../data/phylo.mean.tre")

# compute branch lengths of tree
phylo_branch <- read.tree(file = "../data/phylo.mean.tre") %>%
  compute.brlen(bin.tree, method = "Grafen", power = 1)

# saving phylogeneic matrix
phylo_cor <- vcv(phylo_branch, cor = T)

# Note one of the tips is called "Lates calcarifer (estimated)"
phylo_branch$node.label <- NULL

# Plot tree
plot.phylo(phylo_branch, cex = 0.7)

```
<br>
Phylogenetic tree used. Tree was created for <i>spLL<sub>M</sub></i> based on taxonomic tree on [Open Tree of Life](https://tree.opentreeoflife.org/opentree/argus/opentree12.3@ott93302). Non-binary tree was randomly solved. We used packages `rotl`, `ape` and `phytools` on R.

<div style="margin-bottom:70px;">
</div>

## Dominance
Compare midparent and hybrids by comparing difference from <i>spSS<sub>M</sub></i> phenotypic mean to midparent-value $\frac{spLL_M+spSS_M}{2}$ and to hybrids' phenotypic mean.  

* lnRR of midparent to <i>spSS<sub>M</sub></i>: $\ln\frac{spLL_M+spSS_M}{2spSS_M}$ 
* lnRR of hybrids to <i>spSS<sub>M</sub></i>: $\ln\frac{hybrid}{spSS_M}$ 

As the variance of $\ln\frac{spLL_M+spSS_M}{2spSS_M}$, we use the variance of $\ln\frac{spLL_M}{spSS_M}$ for simplicity <br>

We statistically compared those effect sizes through the formal meta-regression by using `rma.mv` function of R package `metafor` <br>

All meta-analytic models included following Random effects estimates: 

* `Study.ID`: Primary studies. Denoted as **Study**

* `Cross.ID`: Parental strain used in the crossing. Discriminate intraspecific populations. Denoted as **crossed strain**

* `spL.name`: Phylogeny of parental species (<i>spLL<sub>M</sub></i>). Denoted as **species with phylogeny**

```{r}

#++++++++++++++++++++++++++++++++++++++++++++++++++++#
# Calculate midparent 
#++++++++++++++++++++++++++++++++++++++++++++++++++++#
midparent <- Novel.Nonnovel %>%
  # Divide mean by 2 in spL whereas hybrids are constant
  mutate(
    lnRR.midparent.es = 
      ifelse(
        cross == "spL",
        log(((Mn.spL + Mn.spS)/2)/Mn.spS), lnRR.es
        )
    # Divide variance by 4 in spL whereas hybrids are constant
    ) %>%
  mutate_at("cross", as.factor) %>%
  within(levels(cross) <- c("hybLS", "hybSL", "midparent"))


#+++++++++++++++++++++++++++++++++++++++++++++++++++#
# Compare midparent and hybrids by meta-regresson
#+++++++++++++++++++++++++++++++++++++++++++++++++++#
for (j in c("Alltraits", "Nonnoveltraits")) {
  for (k in c("alltaxon", "insect")) {
    
    if (k == "alltaxon") {
      dat <- midparent %>% 
        filter(data.type == j)
    } else {
      dat <- midparent %>% 
        filter(data.type == j, insect == k)
    }
  
    # ### phylogenetic random regresson comparing with midparent ###
    # midparent.compare <- rma.mv(
    #   yi = lnRR.midparent.es,
    #   V = lnRR.sv,
    #   data = dat,
    #   method = "REML",
    #   random = list(~1 | spL.name, ~1 | Study.ID, ~1 | Cross.ID, ~1 | ES.ID),
    #   R = list(spL.name = phylo_cor),
    #   mods = ~ relevel(cross, ref = "midparent")
    #   )
    # ### Save model ###
    # saveRDS(
    #   midparent.compare,
    #   file = paste("../Analysis/Mean.midparent.compare", j, k, "obj", sep = ".")
    #   )

    ### Load model ###
    midparent.compare <- readRDS(paste("../Analysis/Mean.midparent.compare", j, k, "obj", sep = "."))
  
    assign(
      paste("Dominance", j,k, sep = "."),
      get_reg(midparent.compare) %>%
        # Show dataset name
        within(Dataset <- c(paste(j,k), rep("", length(.$Estimate)-1))) %>%
        # Rename fixed effects
        within('Fixed effects' <- c("", "midparent (intrcpt)", "hybLS", "hybSL")) %>%
        # Difference of each cross from midparent in %
        mutate('Comparison with midparent' = c(
          rep("", 2),
          paste(
            round(
            100*(exp(midparent.compare$beta[1]+midparent.compare$beta[2])            -exp(midparent.compare$beta[1])), # hybrid LS
            2),
            "% larger"
            ),
          paste(
            round(
            100*(exp(midparent.compare$beta[1]+midparent.compare$beta[3])-exp(midparent.compare$beta[1])), # hybrid SL
            2),
            "% larger"
            )
          ))
      )
    
    # ### Meta-analysis for midparent to plot band ###
    # midparent.random <- rma.mv(
    #   yi = lnRR.midparent.es,
    #   V = lnRR.sv,
    #   data = dat %>% filter(cross == "midparent"),
    #   method = "REML",
    #   random = list(~1 | spL.name, ~1 | Study.ID, ~1 | Cross.ID, ~1 | ES.ID),
    #   R = list(spL.name = phylo_cor)
    #   )
    # ### Save model ###
    # saveRDS(
    #   midparent.random,
    #   file = paste("../Analysis/Mean.midparent", j, k, "obj", sep = ".")
    #   )

    ### Load model ###
    midparent.random <- readRDS(paste("../Analysis/Mean.midparent", j, k, "obj", sep = "."))
    # creating summary table of results
    assign(
      paste("midparent.ma", j, k, sep = "."),
      # Prediction interval of midparent
      get_pred(midparent.random) %>%
        as.data.frame() %>%
        mutate(
          data.type = j,
          taxon = k
          )
    )
    
  }
}

bind_rows(
  Dominance.Alltraits.alltaxon, Dominance.Nonnoveltraits.alltaxon,
  Dominance.Alltraits.insect, Dominance.Nonnoveltraits.insect
  ) %>%
  kable("html", digits = 3, caption = "Meta-analyses results of full dataset and each data subset") %>% 
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

### Midparent meta-analysis result for plot below ###
midparent.ma <- bind_rows(
  midparent.ma.Alltraits.alltaxon, midparent.ma.Nonnoveltraits.alltaxon,
  midparent.ma.Alltraits.insect, midparent.ma.Nonnoveltraits.insect
  )

```


<div style="margin-bottom:70px;">
</div>

## Univarate meta-analysis for each cross
Quantify and visualise overall trend of phenotypic mean of hybrids compared to parents <br>
Meta-analysis was repeated for subset data - including only non-novel phenotypes, only insects, and non-novel phenotypes in insects <br>
Meta-analysis was conducted by using `rma.mv` function in `metafor` package <br>

*Confidential interval : thick line  

*Prediction interval : thin line

```{r, fig.height = 4, fig.width = 6}

cap <- data.frame(
  Description = c(
    "Orchard plot for full data \n(Alltraits alltaxon)", 
    "Orchard plot for subset data:\n Excluding vertebrates \n(Alltraits insect)",
    "Orchard plot for subset data:\n Including all taxon but excluding novel phenotype \n(Nonnoveltraits alltaxon)",
    "Orchard plot for subset data:\n Excluding vertebrates and novel phenotype\n (Nonnoveltraits insect)"
    )
  ) %>%
  mutate_all(as.character)
row.names(cap) <- c("Alltraits.alltaxon", "Alltraits.insect", 
             "Nonnoveltraits.alltaxon", "Nonnoveltraits.insect")

for (j in c("Alltraits", "Nonnoveltraits")) {
  for (k in c("alltaxon", "insect")) {
    for (h in c("spL", "hybLS", "hybSL")) {

      if (k == "alltaxon") {
        dat <- Novel.Nonnovel %>%
          filter(cross == h, data.type == j)
      } else {
        dat <- Novel.Nonnovel %>%
          filter(cross == h, data.type == j, insect == k)
      }

      # # Phylogenetic random meta-analysis
      # phyl.random <- rma.mv(
      #   yi = lnRR.es, V = lnRR.sv,
      #   data = dat, method = "REML",
      #   random = list(
      #     ~1 | spL.name, ~1 | Study.ID, ~1 | Cross.ID, ~1 | ES.ID
      #     ),
      #   R = list(spL.name = phylo_cor)
      #   )
      # saveRDS(phyl.random,
      #   file = paste("../Analysis/Mean.meta", j, k, h, "obj", sep = "."))

      
      ### Load model ###
      phyl.random <- readRDS(paste("../Analysis/Mean.meta", j, k, h, "obj", sep = "."))
      # Funnel plot
      # funnel(phyl.random, xlab = paste(j, k, h))
      # creating summary table of results
      assign(
        paste("res", h, sep = "."), 
        get_pred(phyl.random) %>%
          as.data.frame() %>%
          mutate(
            N = length(dat$ES.ID),
            # I2 = I2(phyl.random)["I2_total"] %>% round(3),
            cross = h # indicate cross (spL, hybLS, hybSL)
            )
          )
      
    }
    
    if (k == "alltaxon") {
      dat.plot <- Novel.Nonnovel %>% 
        filter(data.type == j)
    } else {
      dat.plot <- Novel.Nonnovel %>% 
        filter(data.type == j, insect == k)
    }

    # Bind result of all crosses at each dataset
    assign(
      paste("res.ma", j,k, sep = "."),
      res.ma <- bind_rows(
        res.spL, res.hybLS, res.hybSL
        ) %>%
        as.data.frame() %>%
        within('Dataset' <- c(paste(j,k), "", "")) # dataset name in first row
    )
    
    ### Midparent estimate & CI ###
    midparent.ma.2 <- midparent.ma %>%
      filter(data.type == j, taxon == k)

    # creating a forest plot
    plot.metamean <- ggplot(
      data = res.ma, 
      aes(x = tanh(Estimate), y = cross)
      ) +
      scale_y_discrete(expand = c(0, 1)) +
      scale_x_continuous(
        limits = c(-1, 1), 
        breaks = seq(-1, 1, by = 0.5)
        ) + 
      ### Midparent CI ###
      geom_rect(
        aes(
          xmin = tanh(midparent.ma.2$LowerCI),
          xmax = tanh(midparent.ma.2$UpperCI),
          ymin = -Inf, ymax = Inf
          ),
        fill="Grey 90"
        ) +
      ### Midparent estimate ###
      geom_vline(
        xintercept = tanh(midparent.ma.2$Estimate), colour = "grey20", 
        alpha = 0.3, size = 1
        ) +
      ### Orchard plot ###
      geom_quasirandom(
        data = dat.plot, 
        aes(x = tanh(lnRR.es), y = cross, size = 1/lnRR.sv, color = cross), 
        alpha = 0.2, groupOnX = FALSE
        ) + 
      scale_color_manual(values = c("#DC267F", "#785EF0", "#FE6100")) +
      # Delete legend for colors
      guides(fill = "none", colour = "none") +
      # Confidential interval : thicker line
      geom_errorbarh(
        aes(xmin = tanh(LowerCI), xmax = tanh(UpperCI)), 
        height = 0, size = 1.2, alpha = 0.6
        ) + 
      # Prediction interval : thinner line
      geom_errorbarh(
        aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)), 
        height = 0.1, size = 0.5, alpha = 0.6
        ) +
      geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
      ### Estimate ###
      geom_point(size = 3, shape = 21, fill = "black") + 
      # ### I^2 ###
      # annotate(
      #   "text", x = -0.93, y = c(1.35, 2.35, 3.35),
      #   label = paste("italic(I^2)==", res.ma$I2), 
      #   parse = TRUE, hjust = "left", size = 5
      # ) + 
      ### N ###
      annotate(
        "text", x = -0.93, y = 3.85,
        label = paste("italic(N)==", length(dat.plot$ES.ID)/3), 
        parse = TRUE, hjust = "left", size = 5
      ) + 
      annotate(
        "text", x = -0.68, y = 3.85,
        label = "each", hjust = "left", size = 5
      ) + 
      ylab("") +
      xlab(expression(
        paste("hyperbolic tangent of lnRR from ", italic("spSS")), 
        parse = TRUE
        )) +
      ggtitle(cap[paste(j,k,sep="."),]) +
      orchardtheme 

    print(plot.metamean)
  
    # ggsave(
    #   plot = plot.metamean,
    #   file = paste("../Analysis/mean.general.metamean", j,k, "svg", sep = "."),
    #   height = 4, width = 5
    #   )
    
  }
}

bind_rows(
  res.ma.Alltraits.alltaxon, res.ma.Nonnoveltraits.alltaxon,
  res.ma.Alltraits.insect, res.ma.Nonnoveltraits.insect
  ) %>%
  as.data.frame() %>%
  # mutate_at(vars('Estimate':'%I2[residual]'), as.numeric) %>%
  # select(Dataset, cross, Estimate, UpperCI, LowerCI, contains("PR"), contains("I2")) %>%
  kable("html", digits = 3, caption = "Meta-analyses results of full dataset and each data subset") %>% 
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

```


<div style="margin-bottom:70px;">
</div>

## Crossing direction effect

We statistically compared lnRR from <i>spSS<sub>M</sub></i> to the other crosses through the formal meta-regression by using `rma.mv` function of R package `metafor`. <br> 

Here we asked if lnRR of <i>hybSL<sub>M</sub></i> was smaller/larger than that of <i>hybLS<sub>M</sub></i> <br>

If $\ln\frac{hybridLS_M}{spSS_M}>\ln\frac{hybridSL_M}{spSS_M}$, <i>hybridLS<sub>M</sub></i> has larger phenotypic mean than <i>hybridSL<sub>M</sub></i> ...maternal inheritance


```{r}

for (j in c("Alltraits", "Nonnoveltraits")) {
  for (k in c("alltaxon", "insect")) {
    
    if (k == "alltaxon") {
      dat <- Novel.Nonnovel %>% 
        filter(data.type == j)
    } else {
      dat <- Novel.Nonnovel %>% 
        filter(data.type == j, insect == k)
    }
  
    # #+++++++++++++++++++++++++++++++++++++++++++++#
    # # phylogenetic random regresson (ANOVA)
    # #+++++++++++++++++++++++++++++++++++++++++++++#
    # # Regress by lnRR of phenotypic difference between parentals
    # phyl.random.spL <- rma.mv(
    #   yi = lnRR.es, V = lnRR.sv,
    #   data = dat, method = "REML",
    #   random = list(~1 | spL.name, ~1 | Study.ID, ~1 | Cross.ID, ~1 | ES.ID),
    #   R = list(spL.name = phylo_cor),
    #   mods = ~ relevel(cross, ref = "spL")
    #   )
    # phyl.random.hybLS <- rma.mv(
    #   yi = lnRR.es, V = lnRR.sv,
    #   data = dat, method = "REML",
    #   random = list(~1 | spL.name, ~1 | Study.ID, ~1 | Cross.ID, ~1 | ES.ID),
    #   R = list(spL.name = phylo_cor),
    #   mods = ~ cross
    #   )
    # # Save model ###
    # saveRDS(
    #   phyl.random.spL,
    #   file = paste("../Analysis/Mean.compare.from.spL", j, k, "obj", sep = ".")
    #   )
    # saveRDS(
    #   phyl.random.hybLS,
    #   file = paste("../Analysis/Mean.compare.from.hybLS", j, k, "obj", sep = ".")
    #   )

    ## Load model ###
    phyl.random.spL <- readRDS(paste("../Analysis/Mean.compare.from.spL", j, k, "obj", sep = "."))
    phyl.random.hybLS <- readRDS(paste("../Analysis/Mean.compare.from.hybLS", j, k, "obj", sep = "."))

  assign(
    paste("Reciprocal", j,k, sep = "."),
    get_reg(phyl.random.hybLS) %>%
      # Show dataset name
      within(Dataset <- c(paste(j,k), rep("", length(.$Estimate)-1))) %>%
      # Rename fixed effects
      within('Fixed effects' <- c("", "hybLS (intrcpt)", "hybSL", "spLL")) %>%
      # Difference of each cross from midparent in %
      mutate('Comparison with hybridLS' = c(
        rep("", 2),
        paste(
          round(
            (exp(phyl.random.hybLS$beta[1]+phyl.random.hybLS$beta[2]) -
               exp(phyl.random.hybLS$beta[1])
             )*100,
            2),
          "% larger"
          ), 
        ""
        )
      )
    )
  }
}

bind_rows(
  Reciprocal.Alltraits.alltaxon, Reciprocal.Nonnoveltraits.alltaxon,
  Reciprocal.Alltraits.insect, Reciprocal.Nonnoveltraits.insect
  ) %>%
  kable("html", digits = 3, caption = "Meta-analyses results of full dataset and each data subset") %>% 
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

```




<div style="margin-bottom:180px;">
</div>
# Meta-analysis for phenotypic variation

### Effect size calculation

We quantified relative phenotypic variability of hybrids and the parent with large variability (<i>spLL<sub>V</sub></i>) to the parent with small variability (<i>spSS<sub>V</sub></i>), by using [lnCVR](https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.12309). We controlled mean-variance relationship by using Coefficient of Variation (CV) as the proxy of phenotypic variability. <br>
Effecct size was calculated by using `escalc` function in `metafor` package 

```{r}

# load spLS files
dat <- read.csv("../data/dat.CV.csv", head = TRUE)

# Order by taxon
dat$taxa <- ordered(
  dat$taxa,
  levels = c("Neuroptera", "Coleoptera", "Diptera", "Lepidoptera", "Orthoptera", "Aves", "Rodentia", "Anura", "Cichliformes")
  )

for (i in c("hybLS", "hybSL", "spL")) { # identify type of hybrids
  for (h in c("spS")) { # identify type of parentals
    assign(
      paste(i, h, sep = "_"),
        escalc(
          measure = "CVR",
          # N of hybrids
          n1i = dat[, paste("N", i, sep = ".")],
          # N of parentals
          n2i = dat[, paste("N", h, sep = ".")],
          # Mean of hybrids
          m1i = dat[, paste("Mn", i, sep = ".")],
          # Mean of parentals
          m2i = dat[, paste("Mn", h, sep = ".")],
          # SD of hybrids
          sd1i = dat[, paste("SD", i, sep = ".")],
          # SD of parentals
          sd2i = dat[, paste("SD", h, sep = ".")],
          data = dat
          ) %>%
          mutate(cross = i) 
    )
  }
}

# Combine all ES datasets
CV.dif <- bind_rows(
  hybLS_spS, hybSL_spS, spL_spS
  ) %>%
  drop_na(yi) %>%
  arrange(ES.ID) %>%
  left_join(., dat) 

```

### Funnel plots

```{r}

res <- rma(yi = yi, vi = vi, data = CV.dif, method="FE")

### set up 2x2 array for plotting
par(mfrow=c(2,2))
### draw funnel plots
funnel(res, main="Standard Error", xlim = c(-5, 5))
funnel(res, yaxis="vi", main="Sampling Variance", xlim = c(-5, 5))
funnel(res, yaxis="seinv", main="Inverse Standard Error", xlim = c(-5, 5))
funnel(res, yaxis="vinv", main="Inverse Sampling Variance", xlim = c(-5, 5))

```

### Check data

Checked effect sizes with extremely high/low standard error (SE > 1.2 | 1/SE > 8.5) and confirmed that those data were correctly imported. 

```{r, results='asis'}

outliers <- CV.dif %>%
  # vi (sampling variance) 
  mutate(SE = sqrt(vi)) %>%
  arrange(desc(SE)) %>%
  filter(SE > 1.2 | 1/SE > 8.5) %>%
  select(ES.ID, Study.name, SE, cross, Reciprocal, trait, Cross.ID) %>%
  mutate_if(is.numeric, round, 3)

outliers %>%
  kable("html", digits = 3, caption = "Effect sizes with extremely high/low standard error (SE > 1.2 | 1/SE > 140)") %>% 
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

CV.dif.2 <- CV.dif %>%
  filter(!ES.ID %in% unique(outliers$ES.ID)) 
write.csv(CV.dif.2, "../data/variation.ES.general.csv", row.names = F)

```
Because they inhibit meta-analytic model convergence, we excluded these outliers from the formal meta-analysis dataset, but not from novel variability dataset.


### Funnel plots again
Funnel plots after outliers excluded
```{r}

res <- rma(yi = yi, vi = vi, data = CV.dif.2, method="FE")
### set up 2x2 array for plotting
par(mfrow=c(2,2))
### draw funnel plots
funnel(res, main="Standard Error", xlim = c(-5, 5))
funnel(res, yaxis="vi", main="Sampling Variance", xlim = c(-5, 5))
funnel(res, yaxis="seinv", main="Inverse Standard Error", xlim = c(-5, 5))
funnel(res, yaxis="vinv", main="Inverse Sampling Variance", xlim = c(-5, 5))

```


### Jugding novel variability expression

```{r}

# load spLS files
dat <- read.csv("../data/dat.CV.csv", head = TRUE)

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++#
# Difference between larger species (spL) and hybrids 
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++#

for (i in c("spL")) { # identify type of hybrids
  for (h in c("hybLS", "hybSL")) { # identify type of parentals
    assign(
      paste(h, i, sep = "_"),
        escalc(
          measure = "CVR",
          # N of hybrids
          n1i = dat[, paste("N", i, sep = ".")],
          # N of parentals
          n2i = dat[, paste("N", h, sep = ".")],
          # Mean of hybrids
          m1i = dat[, paste("Mn", i, sep = ".")],
          # Mean of parentals
          m2i = dat[, paste("Mn", h, sep = ".")],
          # SD of hybrids
          sd1i = dat[, paste("SD", i, sep = ".")],
          # SD of parentals
          sd2i = dat[, paste("SD", h, sep = ".")],
          data = dat
          ) %>%
        select(ES.ID, yi, vi) %>%
        mutate(
          # direction of transgressve segregation - greater than parent
          direction = "+",
          # SE for logistic distribution, for the weighted binomial regression
          # SE = pi/sqrt(3*(n_e + n_c))
          SE = pi/sqrt(3*(
            dat[, paste("N", i, sep = ".")] + dat[, paste("N", h, sep = ".")]
          ))
        )
    )
  }
}

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++#
# Difference between hybrids and smaller species (spS)
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++#

for (i in c("hybLS", "hybSL")) { # identify type of hybrids
  for (h in c("spS")) { # identify type of parentals
    assign(
      paste(i, h, sep = "_"),
        escalc(
          measure = "CVR",
          # N of hybrids
          n1i = dat[, paste("N", i, sep = ".")],
          # N of parentals
          n2i = dat[, paste("N", h, sep = ".")],
          # Mean of hybrids
          m1i = dat[, paste("Mn", i, sep = ".")],
          # Mean of parentals
          m2i = dat[, paste("Mn", h, sep = ".")],
          # SD of hybrids
          sd1i = dat[, paste("SD", i, sep = ".")],
          # SD of parentals
          sd2i = dat[, paste("SD", h, sep = ".")],
          data = dat
          ) %>%
        select(ES.ID, yi, vi) %>%
        mutate(
          # direction of transgressve segregation - smaller than parent
          direction = "-",
          # SE for logistic distribution, for the weighted binomial regression
          # SE = pi/sqrt(3*(n_e + n_c))
          SE = pi/sqrt(3*(
            dat[, paste("N", i, sep = ".")] + dat[, paste("N", h, sep = ".")]
          ))
        )
    )
  }
}


#+++++++++++++++++++++++++++++++++++++++++++++++++++++++#
# Data output
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++#

bind_rows(
  ### Difference with mother species ###
  bind_rows(hybLS_spL, hybSL_spS) %>%
    mutate(parental = "Mother"),
  ### Difference with father species ###
  bind_rows(hybLS_spS, hybSL_spL) %>%
    mutate(parental = "Father")
  ) %>%
  drop_na(yi) %>%
  left_join(., dat) %>%
  # Assign novel variability to 1, non-novel variability to 0 for each effect size
  mutate(Novelty = ifelse(yi < 0, 1, 0)) %>%
  ### Join with metadata ###
  left_join(
    .,
    read.xlsx(
      "../data/original.data.xlsx", sheet = "Species.level.moderators"
      )
    ) %>%
  mutate_at(vars(contains("divergence")), as.numeric) %>%
  mutate_at(vars(contains("divergence")), scale) %>%
  as.data.frame %>%
  select(-trait) %>%
  drop_na(Hetero.sex, trait.type, Genet.divergence) %>%
  # order taxon
  within(
    taxa <- ordered(
      taxa,
      levels = c("Neuroptera", "Coleoptera", "Diptera", "Lepidoptera", "Orthoptera", "Aves", "Rodentia", "Anura", "Cichliformes")
      )
    ) %>%
  mutate_if(is.character, as.factor) %>%
  # Insect or no
  mutate(
    insect = ifelse(taxa %in% c("Aves", "Rodentia", "Anura", "Cichliformes"), "no", "insect"),
  ) %>%
  write.csv("../data/variation.ES.Novelty.csv", row.names = F)

```


### Reload data & Prepare phylogenetic tree

```{r, fig.height = 6.5}

# Load effect sizes
CV.dif <- read.csv("../data/variation.ES.general.csv", head = TRUE)%>%
  # indicate dataset including novel variability
  mutate(data.type = "Alltraits")

# Observations with novel variability
All <- read.csv("../data/variation.ES.novelty.csv", head = TRUE) %>%
  filter(yi < 0) %>%
  distinct(ES.ID)
# Effect sizes with non-novel variability
Nonovel <- read.csv("../data/variation.ES.general.csv", head = TRUE) %>%
  filter(!ES.ID %in% unique(All$ES.ID)) %>%
  # indicate dataset without novel variability
  mutate(data.type = "Nonnoveltraits")

# combine dataset with/without novel variability
Novel.Nonnovel <- bind_rows(CV.dif, Nonovel) %>%
  mutate(metaunit =  str_c(data.type, cross, sep = "_")) %>%
  # Use observations with both reciprocal crosses
  drop_na(contains("Mn"), contains("SD")) %>%
  # Insect or no
  mutate(
    insect = ifelse(taxa %in% c("Cichliformes", "Anura", "Aves", "Rodentia"), "no", "insect"),
  )

#+++++++++++++++++++++++++++++++#
# Phylogeny 
#+++++++++++++++++++++++++++++++#

# # matching names from open tree taxonomy
# taxa <- tnrs_match_names(
#   names = levels(CV.dif$spL.name) %>%
#     str_replace_all("_", " "), 
#   context_name = "Animals"
#   )
# 
# # Create tree
# tree <- tol_induced_subtree(ott_ids = taxa$ott_id)
# tree$tip.label %<>%
#   strip_ott_ids # remove OTT IDs from tip labels
# # randomly solve non-binary phylogeny
# set.seed(6)
# bin.tree <- multi2di(tree, random = T)
# 
# # Fix names of tip labels
# bin.tree$tip.label %<>% str_replace_all("Dryophytes", "Hyla")
# # Indicate mismatch between tip labels & dataset species names
# setdiff(levels(as.factor(bin.tree$tip.label)), levels(CV.dif$spL.name))
# setdiff(levels(CV.dif$spL.name), levels(as.factor(bin.tree$tip.label)))

# write.tree(bin.tree, file= "../data/phylo.variation.tre")

# compute branch lengths of tree
phylo_branch <- read.tree(file = "../data/phylo.variation.tre") %>%
  compute.brlen(bin.tree, method = "Grafen", power = 1)

# saving phylogeneic matrix
phylo_cor <- vcv(phylo_branch, cor = T)

# Note one of the tips is called "Lates calcarifer (estimated)"
phylo_branch$node.label <- NULL

# Plot tree
plot.phylo(phylo_branch, cex = 0.7)

```
<br>
Phylogenetic tree used. Tree was created for <i>spLL<sub>V</sub></i>

<div style="margin-bottom:70px;">
</div>

## Dominance in variance

We compared midparent-value of phenotypic variability and hybrids' phenotypic variability by calculating log ratio of phenotypic variability (lnCVR) of midparent-value and hybrids to <i>spSS<sub>V</sub></i>. <br> 

lnCVR of midparent-value to <i>spSS<sub>V</sub></i> was, following $lnCVR=\ln{\frac{CV_E}{CV_C}}+\frac{1}{2(N_E-1)}-\frac{1}{2(N_C-1)}$ 
, calculated as <br>
$$\ln\frac{CV_{spLL_V}+CV_{spSS_V}}{2}-\ln{CV_{spSS_V}} +  \frac{1}{N_{spLL_V}+N_{spSS_V}-2}-\frac{1}{2(N_{spSS_V} - 1)}$$
It's sampling variance was substitute by that of <i>spLL<sub>V</sub></i> <br>

We statistically compared those effect sizes through the formal meta-regression by using `rma.mv` function of R package `metafor` <br>

All meta-analytic models included following Random effects estimates: 

* `Study.ID`: Primary studies. Denoted as **Study**

* `Cross.ID`: Parental strain used in the crossing. Discriminate intraspecific populations. Denoted as **crossed strain**

* `spL.name`: Phylogeny of parental species (<i>spLL<sub>M</sub></i>). Denoted as **species with phylogeny**

```{r}

#+++++++++++++++++++++++++++++++++++++++++++#
# Calculate midparent 
#+++++++++++++++++++++++++++++++++++++++++++#
midparent <- Novel.Nonnovel %>%
  # Divide mean by 2 in spL whereas hybrids are constant
   mutate(
     CV.spL = SD.spL/Mn.spL,
     CV.spS = SD.spS/Mn.spS
     ) %>%
   mutate(
     lnCVR.midparent.es =
       ifelse(
         cross == "spL",
         # log(CVe/CVc)
         log((CV.spL + CV.spS)/2) - log(CV.spS) +  
           # 1/2(Ne-1) - 1/2(Nc-1)
           1/(N.spL + N.spS -2) - 1/(2*N.spS - 2), 
         yi
         )
     # Divide variance by 4 in spL whereas hybrids are constant
     ) %>%
   mutate_at("cross", as.factor) %>%
   within(levels(cross) <- c("hybLS", "hybSL", "midparent"))


#+++++++++++++++++++++++++++++++++++++++++++++++++++#
# Compare midparent and hybrids by meta-regresson
#+++++++++++++++++++++++++++++++++++++++++++++++++++#

for (j in c("Alltraits", "Nonnoveltraits")) {
  for (k in c("alltaxon", "insect")) {
    
    # Filtering taxon (all taxon or insects)
    if (k == "alltaxon") {
      dat <- midparent %>% 
        filter(data.type == j)
    } else {
      dat <- midparent %>% 
        filter(data.type == j, insect == k)
    }

    # #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
    # # Estimate meta-analytic mean of midparent of phenotypic variation
    # #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
    # midparent.compare <- rma.mv(
    #   yi = lnCVR.midparent.es, V = vi,
    #   data = dat,
    #   method = "REML",
    #   random = list(~1 | spL.name, ~1 | Study.ID, ~1 | Cross.ID, ~1 | ES.ID),
    #   R = list(spL.name = phylo_cor),
    #   mods = ~ relevel(cross, ref = "midparent")
    #   )
    # ### Save model ###
    # saveRDS(
    #   midparent.compare,
    #   file = paste("../Analysis/Variation.midparent.compare", j, k, "obj", sep = ".")
    #   )
  
    ### Load model ###
    midparent.compare <- readRDS(paste("../Analysis/Variation.midparent.compare", j, k, "obj", sep = "."))
    
    assign(
      paste("Dominance", j,k, sep = "."),
      get_reg(midparent.compare) %>%
        # Show dataset name
        within(Dataset <- c(paste(j,k), rep("", length(.$Estimate)-1))) %>%
        # Rename fixed effects
        within('Fixed effects' <- c("", "midparent (intrcpt)", "hybLS", "hybSL")) %>%
        # Difference of each cross from midparent in %
        mutate('Comparison with midparent' = c(
          rep("", 2),
          # Difference hybLS - midparent
          paste(
            round(
            100*(exp(midparent.compare$beta[1]+midparent.compare$beta[2])            -exp(midparent.compare$beta[1])), # hybrid LS
            2),
            "% larger"
            ),
              # beta[1] : midparent
              # beta[2] : hybLS
              # beta[3] : hybSL
          # Difference hybSL - midparent
          paste(
            round(
            100*(exp(midparent.compare$beta[1]+midparent.compare$beta[3])-exp(midparent.compare$beta[1])), # hybrid SL
            2),
            "% larger"
            )
          ))
      )

    # #++++++++++++++++++++++++++++++++++++++++++++++#
    # # Meta-analysis for midparent to plot band
    # #++++++++++++++++++++++++++++++++++++++++++++++#
    # 
    # # Phylogenetic random meta-analysis
    # midparent.random <- rma.mv(
    #   yi = lnCVR.midparent.es,
    #   V = vi,
    #   data = dat %>%
    #     filter(cross == "midparent"),
    #   method = "REML",
    #   random = list(~1 | spL.name, ~1 | Study.ID, ~1 | Cross.ID, ~1 | ES.ID),
    #   R = list(spL.name = phylo_cor)
    #   )
    # ### Save model ###
    # saveRDS(
    #   midparent.random,
    #   file = paste("../Analysis/Variation.midparent", j, k, "obj", sep = ".")
    #   )
    
    ### Load model ###
    midparent.random <- readRDS(paste("../Analysis/Variation.midparent", j, k, "obj", sep = "."))
    # creating summary table of results
    assign(
      paste("midparent.ma", j, k, sep = "."),
      # Prediction interval of midparent
      get_pred(midparent.random) %>%
        as.data.frame() %>%
        mutate(
          data.type = j,
          taxon = k
          )
    )
    
  }
}

bind_rows(
  Dominance.Alltraits.alltaxon, Dominance.Nonnoveltraits.alltaxon,
  Dominance.Alltraits.insect, Dominance.Nonnoveltraits.insect
  ) %>%
  kable("html", digits = 3, caption = "Meta-analyses results of full dataset and each data subset") %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")


### Midparent meta-analysis result for plot below ###
midparent.ma <- bind_rows(
  midparent.ma.Alltraits.alltaxon, midparent.ma.Nonnoveltraits.alltaxon,
  midparent.ma.Alltraits.insect, midparent.ma.Nonnoveltraits.insect
  )

```


<div style="margin-bottom:70px;">
</div>

## Univarate meta-analysis for each cross
Quantify and visualise overall trend of phenotypic variability of hybrids compared to parents <br>
Meta-analysis was repeated for subset data - including only non-novel phenotypes, only insects, and non-novel phenotypes in insects <br>
Meta-analysis was conducted by using `rma.mv` function in `metafor` package <br>

* Confidential interval : thick line  

* Prediction interval : thin line

```{r, fig.height = 4, fig.width = 6}

for (j in c("Alltraits", "Nonnoveltraits")) {
  for (k in c("alltaxon", "insect")) {
    for (h in c("spL", "hybLS", "hybSL")) {

      if (k == "alltaxon") {
        dat <- Novel.Nonnovel %>%
          filter(cross == h, data.type == j)
      } else {
        dat <- Novel.Nonnovel %>%
          filter(cross == h, data.type == j, insect == k)
      }
      
      # # Phylogenetic random meta-analysis
      # phyl.random <- rma.mv(
      #   yi = yi, V = vi,
      #   data = dat, method = "REML",
      #   random = list(~1 | spL.name, ~1 | Study.ID, ~1 | Cross.ID, ~1 | ES.ID),
      #   R = list(spL.name = phylo_cor)
      #   )
      # saveRDS(phyl.random,
      #   file = paste("../Analysis/Variation.meta", j, k, h, "obj", sep = "."))


      ### Load model ###
      phyl.random <- readRDS(paste("../Analysis/Variation.meta", j, k, h, "obj", sep = "."))
      # Funnel plot
      # funnel(phyl.random, xlab = paste(j, k, h))
      # creating summary table of results
      assign(
        paste("res", h, sep = "."), 
        get_pred(phyl.random) %>%
          as.data.frame() %>%
          mutate(
            N = length(dat$ES.ID),
            # I2 = I2(phyl.random)["I2_total"] %>% round(3),
            cross = h # indicate cross (spL, hybLS, hybSL)
            )
          )
      
    }
    
    if (k == "alltaxon") {
      dat.plot <- Novel.Nonnovel %>% 
        filter(data.type == j)
    } else {
      dat.plot <- Novel.Nonnovel %>% 
        filter(data.type == j, insect == k)
    }
    
    
    # Bind result of all crosses at each dataset
    assign(
      paste("res.ma", j,k, sep = "."),
      res.ma <- bind_rows(
        res.spL, res.hybLS, res.hybSL
        ) %>%
        as.data.frame() %>%
        within('Dataset' <- c(paste(j,k), "", "")) # Show dataset name in first row
    )
    
    ### Midparent estimate & CI ###
    midparent.ma.2 <- midparent.ma %>%
      filter(data.type == j, taxon == k)
    
    # creating a forest plot
    plot.metamean <- ggplot(
      data = res.ma,
      aes(x = tanh(Estimate), y = cross)
      ) +
      scale_y_discrete(expand = c(0,1)) +
      scale_x_continuous(
        limits = c(-1, 1),
        breaks = seq(-1, 1, by = 0.5)
        ) +
      ### Midparent CI ###
      geom_rect(
        aes(
          xmin = tanh(midparent.ma.2$LowerCI),
          xmax = tanh(midparent.ma.2$UpperCI),
          ymin = -Inf, ymax = Inf
          ),
        fill="Grey 95", inherit.aes = FALSE
        ) +
      ### Midparent estimate ###
      geom_vline(
        xintercept = tanh(midparent.ma.2$Estimate), colour = "grey20",
        alpha = 0.3, size = 1
        ) +
      ### Orchard plot ###
      geom_quasirandom(
        data = dat.plot %>%
          filter(data.type == j),
        aes(x = tanh(yi), y = cross, size = 1/vi, color = cross),
        alpha = 0.2, groupOnX = FALSE
        ) +
      scale_color_manual(values = c("#DC267F", "#785EF0", "#FE6100")) +
      # Delete legend for colors
      guides(fill = "none", colour = "none") +
      ## Confidential interval ###
      geom_errorbarh(
        aes(xmin = tanh(LowerCI), xmax = tanh(UpperCI)),
        height = 0, size = 1.2, alpha = 0.6
        ) +
      ### Prediction interval ###
      geom_errorbarh(
        aes(xmin = tanh(lowerPR), xmax = tanh(upperPR)),
        height = 0.1, size = 0.5, alpha = 0.6
        ) +
      geom_vline(xintercept = 0, linetype = 2, colour = "black", alpha = 0.3) +
      ### Estimate ###
      geom_point(size = 3, shape = 21, fill = "black") +
      ### N ###
      annotate(
        "text", x = -0.93, y = 3.85,
        label = paste("italic(N)==", length(dat.plot$ES.ID)/3),
        parse = TRUE, hjust = "left", size = 5
      ) +
      annotate(
        "text", x = -0.68, y = 3.85,
        label = "each", hjust = "left", size = 5
      ) +
      ylab("") +
      xlab(expression(
        paste("hyperbolic tangent of lnCVR from ", italic("spSS")),
        parse = TRUE
        )) +
      ggtitle(cap[paste(j,k,sep="."),]) +
      orchardtheme 
    
    print(plot.metamean)

    # ggsave(
    #   plot = plot.metamean,
    #   file = paste("../Analysis/variation.general.metamean", j, k, "svg", sep = "."),
    #   height = 4, width = 5
    # )

  }
}

bind_rows(
  res.ma.Alltraits.alltaxon, res.ma.Nonnoveltraits.alltaxon,
  res.ma.Alltraits.insect, res.ma.Nonnoveltraits.insect
  ) %>%
  as.data.frame() %>%
  select(Dataset, cross, Estimate, UpperCI, LowerCI, contains("PR"), contains("I2")) %>%
  kable("html", digits = 3, caption = "Meta-analyses results of full dataset and each data subset") %>% 
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

```



<div style="margin-bottom:70px;">
</div>

## Crossing direction effect in phenotypic variability

We statistically compared lnCVR from <i>spSS<sub>M</sub></i> to the other crosses through the formal meta-regression by using `rma.mv` function of R package `metafor`. <br> 
Here we asked if lnCVR of <i>hybSL<sub>V</sub></i> was smaller/larger than that of <i>hybLS<sub>V</sub></i>. Smaller lnCVR of <i>hybSL<sub>V</sub></i> indicates maternal inheritance in phenotypic variability <br>

```{r}

for (j in c("Alltraits", "Nonnoveltraits")) {
  for (k in c("alltaxon", "insect")) {
    
    if (k == "alltaxon") {
      dat <- Novel.Nonnovel %>% 
        filter(data.type == j)
    } else {
      dat <- Novel.Nonnovel %>% 
        filter(data.type == j, insect == k)
    }

  #++++++++++++++++++++++++++++++++++++++++++++++#
  # phylogenetic random regresson (ANOVA)
  #++++++++++++++++++++++++++++++++++++++++++++++#
    
  # # Regress by lnRR of phenotypic difference between parentals
  # phyl.random.spL <- rma.mv(
  #   yi = yi, V = vi,
  #   data = dat, method = "REML",
  #   random = list(~1 | spL.name, ~1 | Study.ID, ~1 | Cross.ID, ~1 | ES.ID),
  #   R = list(spL.name = phylo_cor),
  #   mods = ~ relevel(cross, ref = "spL")
  #   )
  # phyl.random.hybLS <- rma.mv(
  #   yi = yi, V = vi,
  #   data = dat, method = "REML",
  #   random = list(~1 | spL.name, ~1 | Study.ID, ~1 | Cross.ID, ~1 | ES.ID),
  #   R = list(spL.name = phylo_cor),
  #   mods = ~ cross
  #   )
  # # Save model ###
  # saveRDS(
  #   phyl.random.spL,
  #   file = paste("../Analysis/Variation.compare.from.spL", j, k, "obj", sep = ".")
  #   )
  # saveRDS(
  #   phyl.random.hybLS,
  #   file = paste("../Analysis/Variation.compare.from.hybLS", j, k, "obj", sep = ".")
  #   )


  ### Load model ###
  # phyl.random.spL <- readRDS(paste("../Analysis/Variation.compare.from.spL", j, k, "obj", sep = "."))
  phyl.random.hybLS <- readRDS(paste("../Analysis/Variation.compare.from.hybLS", j, k, "obj", sep = "."))
  
  assign(
    paste("Reciprocal", j,k, sep = "."),
    get_reg(phyl.random.hybLS) %>%
      # Show dataset name
      within(Dataset <- c(paste(j,k), rep("", length(.$Estimate)-1))) %>%
      # Rename fixed effects
      within('Fixed effects' <- c("", "hybLS (intrcpt)", "hybSL", "spLL")) %>%
      # Difference of each cross from midparent in %
      mutate('Comparison with hybridLS' = c(
        rep("", 2),
        paste(
          round(
            (exp(phyl.random.hybLS$beta[1]+phyl.random.hybLS$beta[2]) -
               exp(phyl.random.hybLS$beta[1])
             )*100,
            2),
          "% larger"
          ), 
        ""
        )
      )
    )
  }
}

bind_rows(
  Reciprocal.Alltraits.alltaxon, Reciprocal.Nonnoveltraits.alltaxon,
  Reciprocal.Alltraits.insect, Reciprocal.Nonnoveltraits.insect
  ) %>%
  kable("html", digits = 3, caption = "Meta-analyses results of full dataset and each data subset") %>% 
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%", height = "500px")

```



<div style="margin-bottom:180px;">
</div>
# Novel phenotype expression

## Frequency

```{r}

dat.full <- read.csv("../data/mean.ES.Novelty.csv", head = TRUE)

### N of novel phenotype in each taxa and each direction ###
summary <- bind_rows(
  # All observations
  dat.full %>%
    group_by(taxa) %>%
    summarise(
      'Species pair' = length(unique(species.pair)),
      Observations = length(unique(ES.ID)),
      Study = length(unique(Study.ID))
      ) %>%
    mutate(direction = "All Observations")
  ,
  # novel phenotype for any direction
  dat.full %>%
    filter(Novelty == "1") %>%
    group_by(taxa) %>%
    summarise(
      'Species pair' = length(unique(species.pair)),
      Observations = length(unique(ES.ID)),
      Study = length(unique(Study.ID))
      ) %>%
    mutate(direction = "Novel phenotype expression")
  ,
  # novel phenotype for each direction
  dat.full %>%
    filter(Novelty == "1") %>%
    group_by(taxa, direction) %>%
    summarise(
      'Species pair' = length(unique(species.pair)),
      Observations = length(unique(ES.ID)),
      Study = length(unique(Study.ID))
      )
  ) %>%
  # Assign 0 for non-novel phenotype
  replace(., is.na(.), "0") %>% 
  # Make tidy data
  gather(key = metrics, value = N, -c(taxa, direction)) %>%
  # Order factors
  mutate_at(vars("metrics", "direction"), as.factor) %>%
  filter(metrics != "Study")

# Order taxon
summary$metrics <- ordered(summary$metrics, levels = c("Study", "Species pair", "Observations"))
# Order novel phenotype category
summary$direction <- ordered(summary$direction, levels = c("All Observations", "Novel phenotype expression", "+", "-"))
# Change names of TS category to more intuitive name
levels(summary$direction) <- c("All Observations", "Novel phenotype expression", "Exceed upper range", "Exceed lower range")

### Plot ###
plot <- ggplot(
  # rename levels of factors to wrap label text
  summary %>%
    within(levels(direction) <- c("All Obser- vations", "Novel phenotype expression", "Exceed upper range", "Exceed lower range")) %>%
    within(levels(metrics) <- c("Study", "Species pair", "Obser- vations")), 
  aes(x = "", y = N, fill = taxa)) +
  geom_bar(width = 1, stat = "identity") +
  scale_fill_brewer(palette = "YlGn") +
  facet_grid(
    scale = "free", metrics ~ direction,
    # strip text into two lines
    labeller = label_wrap_gen(width = 10)
    ) +
  xlab("") + ylab("") +
  stackedbartheme
plot +
  ggtitle("Taxonomic distribution of novel phenotype expression")

# ggsave(
#   plot = plot, 
#   file = "../Analysis/mean.TS.frequency.svg", height = 3.7, width = 5.0
#   )

### Total number of observations and percentage ###
summary %>%
  group_by(direction, metrics) %>%
  # Count number of observaitons and species pairs
  summarise(sum(N)) %>%
  spread(key = metrics, value = "sum(N)") %>%
  as.data.frame() %>%
  # Calculate percentage
  mutate(
    'Species pair %' = .[, "Species pair"]/.[1, "Species pair"]*100,
    'Observaton %' = Observations/.[1, "Observations"]*100
  ) %>%
  mutate_at(vars(contains("percent")), round, 2) %>%
  kable("html", digits = 3, caption = "Summary of the novel phenotype expression frequency") %>% 
  kable_styling("striped", position = "left")

```

<div style="margin-bottom:70px;">
</div>


## Factors affect phenotypic novelty
We checked robustness of results by conducting identical analysis for `insect` subset data (removing vertebrate data). <br>

Model, which was ran using `MCMCglmm` function, included following Random effects estimates: 

* `Study.ID`: Primary studies

* `Cross.ID`: Parental strain used in the crossing. Discriminate intraspecific populations

* `spL.name`: Phylogeny of parental species (<i>spLL<sub>M</sub></i>)

* `SE.units`: Sampling variance of effect size

The moderators were categorised into 3 subsets: main effects (labelled as `novel phenotype expression`), interaction terms with compared parental species (spLL vs. spSS, labelled as `exceed upper range`; mother species vs. father, labelled as `exceed mother`). 

```{r, results = 'asis'}

# Correcting estimate of binomial regression
c2 <- (16 * sqrt(3)/(15 * pi))^2

#++++++++++++++++++++++++++++++++++#
# Phylogenetic tree for mcmcglmm 
#++++++++++++++++++++++++++++++++++#
# compute branch lengths of tree
phylo_branch <- read.tree(file = "../data/phylo.mean.tre") %>%
  compute.brlen(method = "Grafen", power = 1)

# saving phylogeneic matrix
phylo_cor <- vcv(phylo_branch, cor = T)

# generating inverse phylogenetic matrix for MCMCglmm
phylo_branch$node.label <- NULL
phylo_MCMC <- MCMCglmm::inverseA(phylo_branch, nodes = "ALL", scale = TRUE)$Ainv

for (k in c("alltaxon", "insect")) {
  
  if (k == "alltaxon") {
    dat <- dat.full
  } else {
    dat <- dat.full %>% 
      filter(insect == k)
  }

  # ### Setting prior to logistic regression ###
  # prior <- list(
  #   B=list(
  #     mu = rep(0, 17), # N of coefficient. (level -1) for categorical factors, 1 for continuous factors, 1 for intercept
  #     V = gelman.prior(~
  #       parental*Hetero.sex +
  #       parental*direction +
  #       direction*Genet.divergence + direction*Pheno.divergence +
  #       direction*Hetero.sex +
  #       direction*trait.type +
  #       direction*Distribution + direction*Reciprocal,
  #     data = dat, # formula and data
  #     scale=sqrt(pi^2/3+1))), # error distribution of logistic regression
  #   R=list(V=1,fix=1),
  #   G = list(
  #     G1 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
  #     G2 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
  #     G3 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
  #     G4 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000)
  #     )
  #   )
  # ## Phylogenetic binomial regression ###
  # phylmix <-MCMCglmm(
  #   fixed = Novelty ~
  #     parental*Hetero.sex + parental*direction +
  #     direction*Genet.divergence + direction*Pheno.divergence +
  #     direction*Hetero.sex + direction*trait.type +
  #     direction*Distribution + direction*Reciprocal,
  #   # idh(SE):units | weight by SE of effect size
  #   random = ~ Study.ID + Cross.ID + spL.name + idh(SE):units,
  #   family = "categorical",
  #   verbose = FALSE,
  #   ginverse = list(spL.name = phylo_MCMC),
  #   prior = prior,
  #   data = dat,
  #   nitt = 60000,  # Increase the number of iterations, default is 13000
  #   burnin = 5000  # Increase the number of burnin, default is 3000
  # )
  # phylmix$Sol <- phylmix$Sol/sqrt(1+c2)
  # ### Save model ###
  # saveRDS(phylmix, file = paste("../Analysis/Mean.novelty.allfactors", k, "obj", sep = "."))

  #+++++++++++++++++++++++#
  # Grouping variables
  #+++++++++++++++++++++++#
  # Load model
  phylmix <- readRDS(paste("../Analysis/Mean.novelty.allfactors", k, "obj", sep = "."))
  
  sum <- get_fixed.MCMCglmm(summary(phylmix)$solutions) %>%
      ### Grouping Factors ###
      mutate(
        group = 
          ifelse(str_detect(Factors, "direction.:"), 
                 "Exceed upper range",
                 ifelse(str_detect(Factors, "parentalMother:"),
                        "Exceed mother",
                        ifelse(Factors == "Hetero.sexMale:direction+",
                               "Exceed upper range",
                               "Novelty expression"
                               )
                        )
                 )
      ) %>%
      mutate_at("group", as.factor) %>%
      within(group <- ordered(group, c("Novelty expression", "Exceed upper range", "Exceed mother"))) %>%
      ### Change factor names ###
      within(
        Factors <- str_remove_all(
          Factors, "direction.:"
          ) %>%
          str_remove_all(., "parentalMother:") %>%
          str_remove_all(., ":direction.")
        ) %>%
      within(
        Factors <- factor(
          Factors, ordered = TRUE, 
          levels = c("parentalMother", "direction+", "trait.typesound", "Hetero.sexMale", "ReciprocalViable", "DistributionOverlap", "Pheno.divergence",  "Genet.divergence",  "(Intercept)")
          )
        )
  levels(sum$Factors) <- c("Exceed mother", "Exceed upper range", "Sound traits", "Male heterogametic", "Viable reciprocal hybrids", "Distribution overlap", "Phenotypic divergence", "Genetic divergence", "Intercept")

  ### Plot ###
  metaplot <- ggplot(sum, aes(x = post.mean, y = Factors)) +
    # Vertical line
    geom_vline(
      xintercept = 0, size = 0.2, 
      colour = "grey30", linetype = "dotted"         
      ) +
    # CI
    geom_errorbarh(
      aes(
        xmin = sum[, 'l-95% CI'], xmax = sum[, 'u-95% CI'],
        colour=significance 
        ), 
      height = .0001
      ) +
    # Color of plots and errorbars
    scale_colour_manual(values = c("grey60", "black")) +
    geom_point(size = 1, aes(colour = significance)) +
    scale_fill_manual(values = c("grey60", "black")) +
    # Title
    ggtitle(paste("Fixed effects estimates using", k, "data")) +
    ylab("") + xlab("Estimate with 95% CI") +
    # Combine different plots for main Factors and interactions
    facet_grid(
      group~., scales = "free", space = "free",
      labeller = label_wrap_gen(width = 20)
      ) +
    # Themes
    foresttheme
print(metaplot)

  # ggsave(
  #     plot = metaplot,
  #     file = paste("../Analysis/mean.novelty.result", k, "svg", sep = "."),
  #     height = 4.7, width = 4.0
  #     )

  #+++++++++++++++++++++++++#
  # Fixed effects output
  #+++++++++++++++++++++++++#
  sum %>% 
    select(group, Factors, Estimates, '95% credible interval', P, significance, Description) %>%
    kable("html", caption = paste("Fixed effects estimates:", k, "data", " ")) %>% 
    kable_styling("striped", position = "left") %>%
    scroll_box(width = "100%", height = "500px") %>%
    print()
  
  #+++++++++++++++++++++++++++#
  # Random effects output 
  #+++++++++++++++++++++++++++#
  # transformation for varaince
  get_random.MCMCglmm(summary(phylmix$VCV/(1+c2))) %>%
    kable("html", digits = 2,
          caption = paste("Random effects estimates: ", k, "data", " ")
          ) %>% 
    kable_styling("striped", position = "left") %>%
    print()

}

```
While one of significant moderators (`Reciprocal hybrids`) become no longer significant in `insect` subset data, effects are qualitatively the same in sign. 


<div style="margin-bottom:70px;">
</div>

### Effects of significant moderators 
To visually interpret the impacts of significant moderators, we additionally conducted simpler models for each significant factor. As moderators, we included the focal factors, the compared parental species – spLL or spSS, and the interaction between them. Response variables and random effects of simper models were identical to full models. 

```{r, fig.height = 3.5, fig.width = 3.3}

# +++++++++++++++++++++++++++++++++++++++++++#
# To set raw metadata in X axis, reload raw metadata and combine to novelty dataset
# +++++++++++++++++++++++++++++++++++++++++++#
rawdat <- dat.full %>%
  select(-Pheno.divergence, -Genet.divergence) %>%
  # lnRR between parental species as phenotypic distance
  mutate(Pheno.divergence = log(Mn.spL/Mn.spS)) %>%
  left_join(
    .,
    read.xlsx("../data/original.data.xlsx", sheet = "Species.level.moderators") %>%
      select(Cross.ID, Genet.divergence)
    ) %>%
  # Natural log of genetic distance
  mutate_at("Genet.divergence", log) %>%
  mutate_at("direction", as.factor)

# +++++++++++++++++++++++++++++++++++++++++++#
# Regression: Genetic distance
# +++++++++++++++++++++++++++++++++++++++++++#

# ### Setting prior to logistic regression ###
# prior <- list(
#   B=list(
#     mu = rep(0, 3), # N of coefficient. (level -1) for categorical factors, 1 for continuous factors, 1 for intercept
#     V = gelman.prior(~ direction:Genet.divergence + Genet.divergence,
#     data = rawdat, # formula and data
#     scale=sqrt(pi^2/3+1))), # error distribution of logistic regression
#   R=list(V=1,fix=1),
#   G = list(
#     G1 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#     G2 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#     G3 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#     G4 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000)
#     )
#   )
# ## Phylogenetic binomial regression ###
# phylmix <-MCMCglmm(
#   fixed = Novelty ~ direction:Genet.divergence + Genet.divergence,
#   # idh(SE):units | weight by SE of effect size
#   random = ~ Study.ID + Cross.ID + spL.name + idh(SE):units,
#   family = "categorical",
#   verbose = FALSE,
#   ginverse = list(spL.name = phylo_MCMC),
#   prior = prior,
#   data = rawdat,
#   nitt = 60000,  # Increase the number of iterations, default is 13000
#   burnin = 5000  # Increase the number of burnin, default is 3000
# )
# phylmix$Sol <- phylmix$Sol/sqrt(1+c2)
# ### Save model ###
# saveRDS(phylmix, file ="../Analysis/Mean.novelty.Genet.divergence.obj")

# +++++++++++++++++++++++++++++++++++++++++++#
# Regression: Phenotypic divergence
# +++++++++++++++++++++++++++++++++++++++++++#
# ### Setting prior to logistic regression ###
# prior <- list(
#   B=list(
#     mu = rep(0, 3), # N of coefficient. (level -1) for categorical factors, 1 for continuous factors, 1 for intercept
#     V = gelman.prior(~ direction:Pheno.divergence + Pheno.divergence,
#     data = rawdat, # formula and data
#     scale=sqrt(pi^2/3+1))), # error distribution of logistic regression
#   R=list(V=1,fix=1),
#   G = list(
#     G1 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#     G2 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#     G3 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#     G4 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000)
#     )
#   )
# ## Phylogenetic binomial regression ###
# phylmix <-MCMCglmm(
#   fixed = Novelty ~ direction:Pheno.divergence + Pheno.divergence,
#   # idh(SE):units | weight by SE of effect size
#   random = ~ Study.ID + Cross.ID + spL.name + idh(SE):units,
#   family = "categorical",
#   verbose = FALSE,
#   ginverse = list(spL.name = phylo_MCMC),
#   prior = prior,
#   data = rawdat,
#   nitt = 60000,  # Increase the number of iterations, default is 13000
#   burnin = 5000  # Increase the number of burnin, default is 3000
# )
# phylmix$Sol <- phylmix$Sol/sqrt(1+c2)
# ### Save model ###
# saveRDS(phylmix, file ="../Analysis/Mean.novelty.Pheno.divergence.obj")

#++++++++++++++++++++++++++++++++++++++++++++++++++#
# Plot
#++++++++++++++++++++++++++++++++++++++++++++++++++#
for (i in c("Genet.divergence", "Pheno.divergence")) {
  
  ### Load model ###
  phylmix <- readRDS(
    paste("../Analysis/Mean.novelty",i, "obj", sep = ".")
    )
  reg <- summary(phylmix$Sol)$statistics %>%
      as.data.frame()
  
  ### Plot ###
  plot <- ggplot(rawdat, aes(x = rawdat[,i], y = rawdat[, "Novelty"])) +
    geom_jitter(
      height = 0.1, width = 0, aes(color = direction), alpha = 0.3, size = 0.2
      ) +
    # novelty for larger mean
    stat_function(
      aes(color = "+"), size = 0.8,
      fun = function(x) 
        1/(1 + exp(-(reg[1,1] + x*(reg[2,1]+reg[3,1]))))
      ) +
    # novelty for smaller mean
    stat_function(
      aes(color = "-"), size = 0.8,
      fun = function(x) 
        1/(1 + exp(-(reg[1,1] + x*reg[2,1])))
      ) +
    ylab("Novel phenotype expression") + 
    xlab(paste(i, "(log)")) +
    scale_color_manual(values = c("#648FFF", "#FE6100")) + 
    scale_y_continuous(breaks=seq(0,1)) +
    regressiontheme 
  print(plot)
  # ggsave(
  #   plot = plot + theme(axis.title  = element_blank()),
  #   file = paste("../Analysis/mean.TS.continuous", i, "svg", sep = "."),
  #   height = 1.6, width = 1.7
  #   )

}

```

```{r, results='asis', fig.height = 3, fig.width = 6}

for (i in c("Reciprocal", "trait.type")) {

    # Make new categorical data combining direction of TS and target categorical factor
    dat %<>%
      mutate(interaction = str_c(direction, .[, i], sep = "_"))
    
    
    # ### Setting prior to logistic regression ###
    # prior <- list(
    #   B=list(
    #     mu = rep(0, 4), # N of coefficient. (level -1) for categorical factors, 1 for continuous factors, 1 for intercept
    #     V = gelman.prior(~ interaction, # + trait.direction
    #     data = dat, # formula and data
    #     scale=sqrt(pi^2/3+1))), # error distribution of logistic regression
    #   R=list(V=1,fix=1),
    #   # Replicating same G for the number of random effects (here, 4)
    #   G = list(
    #     G1 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
    #     G2 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
    #     G3 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
    #     G4 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000)
    #     )
    #   )
    # 
    # phylmix <-MCMCglmm(
    #   fixed = Novelty ~  interaction -1, # + trait.direction
    #   family = "categorical",
    #   # idh(SE):units | weight by SE of effect size
    #   random = ~ Study.ID + Cross.ID + spL.name + idh(SE):units,
    #   verbose = FALSE,
    #   ginverse = list(spL.name = phylo_MCMC),
    #   prior = prior,
    #   data = dat
    # )
    # # Correct model result
    # phylmix$Sol <- phylmix$Sol/sqrt(1+c2)
    # ### Save model ###
    # saveRDS(
    #   phylmix,
    #   file =
    #     paste("../Analysis/Mean.novelty", i, "alltaxon.obj", sep = ".")
    #     )

  #++++++++++++++++++++++++++++++++++++++#  
  # Grouping interaction terms
  #++++++++++++++++++++++++++++++++++++++#
  phylmix <- readRDS(
    paste("../Analysis/Mean.novelty", i, "alltaxon.obj", sep = ".")
    )
  
  sum <- summary(phylmix)$solutions %>%
    as.data.frame() %>%
    rownames_to_column(var = "factors") %>%
    mutate(
      # Impact on exceeding upper or lower range
      direction =
        ifelse(str_detect(factors, "interaction\\+"), 
               "Exceed upper range",
               "Exceed lower range"
               ) %>%
        as.factor
      ) %>%
    within(direction <- ordered(direction, c("Exceed upper range", "Exceed lower range"))) %>%
    ### Change factor names ###
    within(
      factors <- str_remove_all(factors, "interaction._")
      )       
  
    #++++++++++++++++++++++++++++++++++++++#  
    # Plot
    #++++++++++++++++++++++++++++++++++++++#
    categoricalplot <- ggplot(sum, aes(x = post.mean, y = factors)) +
      # Vertical line
      geom_vline(
        xintercept = 0, size = 0.3,
        colour = "grey30", linetype = "dotted"
        ) +
      # CI
      geom_errorbarh(
        aes(xmin = sum[, 'l-95% CI'], xmax = sum[, 'u-95% CI']),
        height = .0001
        ) +
      geom_point(size = 1.3, shape = 17) +
      # Title
      ylab("") + xlab("Effect on novel phenotype expression") +
      ggtitle(i) +
      # Combine different plots for main factors and interactions
      facet_grid(
        direction ~., scales = "free", drop = TRUE,
        labeller = label_wrap_gen(width = 11)
        ) +
      foresttheme
    print(categoricalplot)
  
    # ggsave(
    #     plot = categoricalplot + theme(axis.text.y = element_blank()),
    #     file = paste("../Analysis/Mean.TS.categorical", i,k, "svg", sep = "."),
    #     height = 1.8, width = 2.5
    #     )

}

```




<div style="margin-bottom:180px;">
</div>
# Novel variability expression

## Frequency

```{r}

dat.full <- read.csv("../data/variation.ES.Novelty.csv", head = TRUE)

### N of TS in each taxa and each direction ###
summary <- bind_rows(
  # All observations
  dat.full %>%
    group_by(taxa) %>%
    summarise(
      'Species pair' = length(unique(species.pair)),
      Observations = length(unique(ES.ID)),
      Study = length(unique(Study.ID))
      ) %>%
    mutate(direction = "All Observations")
  ,
  # TS for any direction
  dat.full %>%
    filter(Novelty == "1") %>%
    group_by(taxa) %>%
    summarise(
      'Species pair' = length(unique(species.pair)),
      Observations = length(unique(ES.ID)),
      Study = length(unique(Study.ID))
      ) %>%
    mutate(direction = "Novel variability expression")
  ,
  # TS for each direction
  dat.full %>%
    filter(Novelty == "1") %>%
    group_by(taxa, direction) %>%
    summarise(
      'Species pair' = length(unique(species.pair)),
      Observations = length(unique(ES.ID)),
      Study = length(unique(Study.ID))
      )
  ) %>%
  # Assign 0 for no observation of TS
  replace(., is.na(.), "0") %>% 
  # Make tidy data
  gather(key = metrics, value = N, -c(taxa, direction)) %>%
  # Order factors
  mutate_at(vars("metrics", "direction"), as.factor) %>%
  filter(metrics != "Study")

# Order taxon
summary$metrics <- ordered(summary$metrics, levels = c("Study", "Species pair", "Observations"))
# Order TS category
summary$direction <- ordered(summary$direction, levels = c("All Observations", "Novel variability expression", "+", "-"))
# Change names of TS category to more intuitive name
levels(summary$direction) <- c("All Observations", "Novel variability expression", "Exceed upper range", "Exceed lower range")

### Plot ###
plot <- ggplot(
  # rename levels of factors to wrap label text
  summary %>%
    within(levels(direction) <- c("All Obser- vations", "Novel variability expression", "Exceed upper range", "Exceed lower range")) %>%
    within(levels(metrics) <- c("Study", "Species pair", "Obser- vations")), 
  aes(x = "", y = N, fill = taxa)) +
  geom_bar(width = 1, stat = "identity") +
  scale_fill_brewer(palette = "YlGn") +
  facet_grid(
    scale = "free", metrics ~ direction,
    # strip text into two lines
    labeller = label_wrap_gen(width = 10)
    ) +
  xlab("") + ylab("") +
  stackedbartheme
plot +
  ggtitle("Taxonomic distribution of novel variability expression")

# ggsave(
#   plot = plot,
#   file = "../Analysis/Variation.TS.frequency.svg", height = 3.7, width = 5.0
#   )

### Total number of observations and percentage ###
summary %>%
  group_by(direction, metrics) %>%
  # Count number of observaitons and species pairs
  summarise(sum(N)) %>%
  spread(key = metrics, value = "sum(N)") %>%
  as.data.frame() %>%
  # Calculate percentage
  mutate(
    'Species pair %' = .[, "Species pair"]/.[1, "Species pair"]*100,
    'Observaton %' = Observations/.[1, "Observations"]*100
  ) %>%
  mutate_at(vars(contains("percent")), round, 2) %>%
  kable("html", digits = 3, caption = "Summary of the novel variability expression frequency") %>% 
  kable_styling("striped", position = "left")

```

<div style="margin-bottom:70px;">
</div>

## Factors affect novel variability
We checked robustness of results by conducting identical analysis for `insect` subset data (removing vertebrate data). <br>

Model, which was ran using `MCMCglmm` function, included following Random effects estimates: 

* `Study.ID`: Primary studies

* `Cross.ID`: Parental strain used in the crossing. Discriminate intraspecific populations

* `spL.name`: Phylogeny of parental species (<i>spLL<sub>V</sub></i>)

* `SE.units`: Sampling variance of effect size

The moderators were categorised into 3 subsets: main effects (labelled as `novel variability expression`), interaction terms with compared parental species (spLL vs. spSS, labelled as `exceed upper range`; mother species vs. father, labelled as `exceed mother`). 

```{r, results='asis'}

#++++++++++++++++++++++++++++++++++#
# Phylogenetic tree for mcmcglmm 
#++++++++++++++++++++++++++++++++++#

# compute branch lengths of tree
phylo_branch <- read.tree(file = "../data/phylo.variation.tre") %>%
  compute.brlen(method = "Grafen", power = 1)

# saving phylogeneic matrix
phylo_cor <- vcv(phylo_branch, cor = T)

# generating inverse phylogenetic matrix for MCMCglmm
phylo_branch$node.label <- NULL
phylo_MCMC <- MCMCglmm::inverseA(phylo_branch, nodes = "ALL", scale = TRUE)$Ainv


#+++++++++++++++++++++++++++++++++++++#
# Phylogenetic comparative analysis
#+++++++++++++++++++++++++++++++++++++#

for (k in c("alltaxon", "insect")) {
  
  if (k == "alltaxon") {
    dat <- dat.full
  } else {
    dat <- dat.full %>% 
      filter(insect == k)
  }
  
  # ### Setting prior to logistic regression ###
  # prior <- list(
  #   B=list(
  #     mu = rep(0, 17), # N of coefficient. (level -1) for categorical factors, 1 for continuous factors, 1 for intercept
  #     V = gelman.prior(~
  #     parental*Hetero.sex + parental*direction +
  #     direction*Genet.divergence + direction*Pheno.divergence +
  #     direction*Hetero.sex + direction*trait.type +
  #     direction*Distribution + direction*Reciprocal,
  #     data = dat, # formula and data
  #     scale=sqrt(pi^2/3+1))), # error distribution of logistic regression
  #   R=list(V=1,fix=1),
  #   # Replicating same G for the number of random effects (here, 4)
  #   G = list(
  #     G1 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
  #     G2 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
  #     G3 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
  #     G4 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000)
  #     )
  #   )
  # ### Phylogenetic binomial regression ###
  # phylmix <-MCMCglmm(
  #   fixed = Novelty ~
  #     parental*Hetero.sex + parental*direction +
  #     direction*Genet.divergence + direction*Pheno.divergence +
  #     direction*Hetero.sex + direction*trait.type +
  #     direction*Distribution + direction*Reciprocal,
  #   family = "categorical",
  #   # idh(SE):units | weight by SE of effect size
  #   random = ~ Study.ID + Cross.ID + spL.name + idh(SE):units,
  #   verbose = FALSE,
  #   ginverse = list(spL.name = phylo_MCMC),
  #   prior = prior,
  #   data = dat,
  #   nitt = 60000,  # Increase the number of iterations, default is 13000
  #   burnin = 5000  # Increase the number of burnin, default is 3000
  # )
  # ### Correcting estimate ###
  # phylmix$Sol <- phylmix$Sol/sqrt(1+c2)
  # ### Save model ###
  # saveRDS(
  #   phylmix,
  #   file = paste("../Analysis/Variation.novelty.allfactors", k, "obj", sep = ".")
  #   )
  
  ### Load model ###
  phylmix <- readRDS(file = paste("../Analysis/Variation.novelty.allfactors", k, "obj", sep = "."))
  
  sum <- get_fixed.MCMCglmm(summary(phylmix)$solutions) %>%
    ### Grouping Factors ###
    mutate(
      group = 
        ifelse(str_detect(Factors, "direction.:"), 
               "Exceed upper range",
               ifelse(str_detect(Factors, "parentalMother:"),
                      "Exceed mother",
                      ifelse(Factors == "Hetero.sexMale:direction+",
                             "Exceed upper range",
                             "Novel variability expression"
                             )
                      )
               )
    ) %>%
    mutate_at("group", as.factor) %>%
    within(group <- ordered(group, c("Novel variability expression", "Exceed upper range", "Exceed mother"))) %>%
    ### Change factor names ###
    within(
      Factors <- str_remove_all(
        Factors, "direction.:"
        ) %>%
        str_remove_all(., "parentalMother:") %>%
        str_remove_all(., ":direction.")
      ) %>%
    within(
      Factors <- factor(
        Factors, ordered = TRUE, 
        levels = c("parentalMother", "direction+", "trait.typesound", "Hetero.sexMale", "ReciprocalViable", "DistributionOverlap", "Pheno.divergence",  "Genet.divergence",  "(Intercept)")
        )
      )
  levels(sum$Factors) <- c("Exceed mother", "Exceed upper range", "Sound traits", "Male heterogametic", "Viable reciprocal hybrids", "Distribution overlap", "Phenotypic divergence", "Genetic divergence", "Intercept")
  
  ### Plot ###
  metaplot <- ggplot(sum, aes(x = post.mean, y = Factors)) +
    # Vertical line
    geom_vline(
      xintercept = 0, size = 0.2, 
      colour = "grey30", linetype = "dotted"         
      ) +
    # CI
    geom_errorbarh(
      aes(
        xmin = sum[, 'l-95% CI'], xmax = sum[, 'u-95% CI'],
        colour=significance 
        ), 
      height = .0001
      ) +
    # Color of plots and errorbars
    scale_colour_manual(values = c("grey60", "black")) +
    geom_point(size = 1, aes(colour = significance)) +
    scale_fill_manual(values = c("grey60", "black")) +
    # Title
    ggtitle(paste("Fixed effects estimates using", k, "data")) +
    ylab("") + xlab("Estimate with 95% CI") +
    # Combine different plots for main Factors and interactions
    facet_grid(
      group~., scales = "free", space = "free",
      labeller = label_wrap_gen(width = 20)
      ) +
    # Themes
    foresttheme
  print(metaplot)
  
  # ggsave(
  #     plot = metaplot, 
  #     file = paste("../Analysis/variation.TS.result", k, "svg", sep = "."), 
  #     height = 4.7, width = 4.0
  #     )
  
  #+++++++++++++++++++++++++#
  # Fixed effects output
  #+++++++++++++++++++++++++#
  sum %>% 
    select(group, Factors, Estimates, '95% credible interval', P, significance, Description) %>%
    kable("html", caption = paste("Fixed effects estimates:", k, "data", " ")) %>% 
    kable_styling("striped", position = "left") %>%
    scroll_box(width = "100%", height = "500px") %>%
    print()
  
  #+++++++++++++++++++++++++++#
  # Random effects output 
  #+++++++++++++++++++++++++++#
  # transformation for varaince
  get_random.MCMCglmm(summary(phylmix$VCV/(1+c2))) %>%
    kable("html", digits = 2,
          caption = paste("Random effects estimates: ", k, "data", " ")
          ) %>% 
    kable_styling("striped", position = "left") %>%
    print()
  
}

```
While significant moderators become no longer significant in `insect` subset data, effects are qualitatively the same in sign.  

<div style="margin-bottom:70px;">
</div>

### Effects of significant moderators 
To visually interpret the impacts of significant moderators, we additionally conducted simpler models for each significant factor. As moderators, we included the focal factors, the compared parental species – spLL or spSS, and the interaction between them. Response variables and random effects of simper models were identical to full models. 

```{r, fig.height = 3.5, fig.width = 3.3}

# +++++++++++++++++++++++++++++++++++++++++++#
# To set raw metadata in X axis, reload raw metadata and combine to transgression dataset
# +++++++++++++++++++++++++++++++++++++++++++#
rawdat <- dat.full %>%
  select(-Pheno.divergence, -Genet.divergence) %>%
  # lnRR between parental species as phenotypic distance
  mutate(Pheno.divergence = abs(log(Mn.spL/Mn.spS))) %>%
  left_join(
    .,
    read.xlsx("../data/original.data.xlsx", sheet = "Species.level.moderators") %>%
      select(Cross.ID, Genet.divergence)
    ) %>%
  # Natural log of genetic distance
  mutate_at("Genet.divergence", log)

# # +++++++++++++++++++++++++++++++++++++++++++#
# # Regression: Genetic distance
# # +++++++++++++++++++++++++++++++++++++++++++#
# 
# ### Setting prior to logistic regression ###
# prior <- list(
#   B=list(
#     mu = rep(0, 3), # N of coefficient. (level -1) for categorical factors, 1 for continuous factors, 1 for intercept
#     V = gelman.prior(~ direction:Genet.divergence + Genet.divergence,
#     data = rawdat, # formula and data
#     scale=sqrt(pi^2/3+1))), # error distribution of logistic regression
#   R=list(V=1,fix=1),
#   G = list(
#     G1 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#     G2 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#     G3 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#     G4 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000)
#     )
#   )
# ## Phylogenetic binomial regression ###
# phylmix <-MCMCglmm(
#   fixed = Novelty ~ direction:Genet.divergence + Genet.divergence,
#   # idh(SE):units | weight by SE of effect size
#   random = ~ Study.ID + Cross.ID + spL.name + idh(SE):units,
#   family = "categorical",
#   verbose = FALSE,
#   ginverse = list(spL.name = phylo_MCMC),
#   prior = prior,
#   data = rawdat,
#   nitt = 60000,  # Increase the number of iterations, default is 13000
#   burnin = 5000  # Increase the number of burnin, default is 3000
# )
# phylmix$Sol <- phylmix$Sol/sqrt(1+c2)
# ### Save model ###
# saveRDS(phylmix, file ="../Analysis/Variation.novelty.Genet.divergence.obj")
# 
# # +++++++++++++++++++++++++++++++++++++++++++#
# # Regression: Phenotypic divergence
# # +++++++++++++++++++++++++++++++++++++++++++#
# 
# ### Setting prior to logistic regression ###
# prior <- list(
#   B=list(
#     mu = rep(0, 3), # N of coefficient. (level -1) for categorical factors, 1 for continuous factors, 1 for intercept
#     V = gelman.prior(~ direction:Pheno.divergence + Pheno.divergence,
#     data = rawdat, # formula and data
#     scale=sqrt(pi^2/3+1))), # error distribution of logistic regression
#   R=list(V=1,fix=1),
#   G = list(
#     G1 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#     G2 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#     G3 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#     G4 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000)
#     )
#   )
# ## Phylogenetic binomial regression ###
# phylmix <-MCMCglmm(
#   fixed = Novelty ~ direction:Pheno.divergence + Pheno.divergence,
#   # idh(SE):units | weight by SE of effect size
#   random = ~ Study.ID + Cross.ID + spL.name + idh(SE):units,
#   family = "categorical",
#   verbose = FALSE,
#   ginverse = list(spL.name = phylo_MCMC),
#   prior = prior,
#   data = rawdat,
#   nitt = 60000,  # Increase the number of iterations, default is 13000
#   burnin = 5000  # Increase the number of burnin, default is 3000
# )
# phylmix$Sol <- phylmix$Sol/sqrt(1+c2)
# ### Save model ###
# saveRDS(phylmix, file ="../Analysis/Variation.novelty.Pheno.divergence.obj")

#++++++++++++++++++++++++++++++++++++++++++++++++++#
# Plot
#++++++++++++++++++++++++++++++++++++++++++++++++++#

for (i in c("Genet.divergence", "Pheno.divergence")) {
  
  ### Load model ###
  phylmix <- readRDS(
    paste("../Analysis/Variation.novelty",i, "obj", sep = ".")
    )
  reg <- summary(phylmix$Sol)$statistics %>%
      as.data.frame()
  
  ### Plot ###
  plot <- ggplot(rawdat, aes(x = rawdat[,i], y = rawdat[, "Novelty"])) +
    geom_jitter(
      height = 0.1, width = 0, aes(color = direction), alpha = 0.3, size = 0.2
      ) +
    # Larger variability
    stat_function(
      aes(color = "+"), size = 0.8,
      fun = function(x) 
        1/(1 + exp(-(reg[1,1] + x*(reg[2,1]+reg[3,1]))))
      ) +
    # Smaller variability
    stat_function(
      aes(color = "-"), size = 0.8,
      fun = function(x) 
        1/(1 + exp(-(reg[1,1] + x*reg[2,1])))
      ) +
    ylab("Novel variability expression") + 
    xlab(paste(i, "(log)")) +
    scale_color_manual(values = c("#648FFF", "#FE6100")) + 
    scale_y_continuous(breaks=seq(0,1)) +
    regressiontheme 
  
  print(plot)
  # ggsave(
  #   plot = plot, 
  #   file = paste("../Analysis/Variation.TS.continuous", i, "svg", sep = "."), 
  #   height = 1.6, width = 1.7
  #   )

}

```

```{r, results='asis', fig.height = 3, fig.width = 6}

for (i in c("Reciprocal", "trait.type")) {

  # Make new categorical data combining direction of TS and target categorical factor
  dat %<>%
    mutate(interaction = str_c(direction, .[, i], sep = "_"))

  # ### Setting prior to logistic regression ###
  # prior <- list(
  #   B=list(
  #     mu = rep(0, 4), # N of coefficient. (level -1) for categorical factors, 1 for continuous factors, 1 for intercept
  #     V = gelman.prior(~ interaction,
  #     data = dat, # formula and data
  #     scale=sqrt(pi^2/3+1))), # error distribution of logistic regression
  #   R=list(V=1,fix=1),
  #   # Replicating same G for the number of random effects (here, 4)
  #   G = list(
  #     G1 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
  #     G2 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
  #     G3 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
  #     G4 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000)
  #     )
  #   )
  # ### Run model ###
  # phylmix <-MCMCglmm(
  #   fixed = Novelty ~  interaction -1, # + trait.direction
  #   family = "categorical",
  #   # idh(SE):units | weight by SE of effect size
  #   random = ~ Study.ID + Cross.ID + spL.name + idh(SE):units,
  #   verbose = FALSE,
  #   ginverse = list(spL.name = phylo_MCMC),
  #   prior = prior,
  #   data = dat
  # )
  # # Correcting estimate
  # phylmix$Sol <- phylmix$Sol/sqrt(1+c2)
  # ### Save model ###
  # saveRDS(
  #   phylmix,
  #   file =
  #     paste("../Analysis/Variation.novelty", i, "alltaxon.obj", sep = ".")
  #     )
  
  #++++++++++++++++++++++++++++++++++++++#  
  # Grouping interaction terms
  #++++++++++++++++++++++++++++++++++++++#
  phylmix <- readRDS(
    paste("../Analysis/Variation.novelty", i, "alltaxon.obj", sep = ".")
    )
  
  sum <- summary(phylmix)$solutions %>%
    as.data.frame() %>%
    rownames_to_column(var = "factors") %>%
    mutate(
      # Impact on exceeding upper or lower range
      direction =
        ifelse(str_detect(factors, "interaction\\+"), 
               "Exceed upper range",
               "Exceed lower range"
               ) %>%
        as.factor
      ) %>%
    within(direction <- ordered(direction, c("Exceed upper range", "Exceed lower range"))) %>%
    ### Change factor names ###
    within(
      factors <- str_remove_all(factors, "interaction._")
      )       
  
    #++++++++++++++++++++++++++++++++++++++#  
    # Plot
    #++++++++++++++++++++++++++++++++++++++#
    categoricalplot <- ggplot(sum, aes(x = post.mean, y = factors)) +
      # Vertical line
      geom_vline(
        xintercept = 0, size = 0.3,
        colour = "grey30", linetype = "dotted"
        ) +
      # CI
      geom_errorbarh(
        aes(xmin = sum[, 'l-95% CI'], xmax = sum[, 'u-95% CI']),
        height = .0001
        ) +
      geom_point(size = 1.3, shape = 17) +
      # Title
      ylab("") + xlab("Effect on novel phenotype expression") +
      ggtitle(i) +
      # Combine different plots for main factors and interactions
      facet_grid(
        direction ~., scales = "free", drop = TRUE,
        labeller = label_wrap_gen(width = 11)
        ) +
      foresttheme
    print(categoricalplot)
  
  # ggsave(
  #     plot = categoricalplot + theme(axis.text.y = element_blank()),
  #     file = 
  #       paste("../Analysis/Variation.novelty.categorical", i,k, "svg", sep = "."),
  #     height = 1.8, width = 2.5
  #     )
  
}


```

<div style="margin-bottom:180px;">
</div>

# Phenotypic variability of novel phenotype

## Dataset summary

Relative variability indicates F1 hybrids' phenotypic variability size (CV) compared to those of parents. <br>

* Smaller: smaller variability than of both parents

* Intermediate: intermediate between parents' variability 

* Larger: larger variability than of both parents

```{r, results='asis'}

dat <- read.csv("../data/dat.novelty.csv", head = TRUE) %>% 
  mutate_at(vars("mean.novelty", "relative.var"), as.factor) %>% 
  within(
    relative.var <-
      ordered(relative.var, levels = c("Smaller", "Intermediate", "Larger")),
    mean.novelty <- 
      ordered(mean.novelty, levels = c("Nonnovel", "Novel"))
  )

dat.relat.var <- dat %>% 
  group_by(mean.novelty, relative.var) %>% 
  summarise('N (Trait observation)' = length(ES.ID)) %>% 
  spread(key = mean.novelty, value = 'N (Trait observation)') %>%
  as.data.frame() %>%
  mutate(
    "Nonnovel phenotype (% trait obs)" = 
      Nonnovel/sum(Nonnovel)*100, 
    "Novel phenotype (% trait obs)" = 
      Novel/sum(Novel)*100,
    Trait.count = Nonnovel + Novel # N of traits at each variability levels
  ) %>%
  rename('Relative.variability' = 'relative.var')

ggplot(
  dat.relat.var %>%
    dplyr::select(-contains("trait obs"), -Trait.count) %>%
    pivot_longer(
      col = -Relative.variability,
      names_to = "Phenotypic.novelty",
      values_to = "Count"
      ) %>%
    left_join(dat.relat.var) %>%
    as.data.frame %>%
    mutate_at("Phenotypic.novelty", as.factor),
  aes(
    y = Count, 
    x = Trait.count/2,  # ensure each pie chart is "left-aligned"
    width = Trait.count, # sample size (N of traits at each variability levels)
    fill = Phenotypic.novelty
    )
  ) +
  geom_bar(position="fill", stat = "identity") +
  facet_grid(~ Relative.variability) +
  # Pie chart
  coord_polar("y") +
  ggtitle("Novel and non-novel phenotypes occupancies at
          each relative variability levels") +
  xlab("Trait counts") + ylab("Relative variability levels") +
  theme(axis.text.x = element_blank())


dat.relat.var %>%
  rename(
  'Nonnovel.phenotype (N)' = 'Nonnovel',
  'Novel.phenotype (N)' = 'Novel'
  ) %>%
  kable("html", digits = 1, caption = "Dataset summary") %>%
  kable_styling("striped", position = "left")

```

<div style="margin-bottom:70px;">
</div>

## Phylogeny

```{r, fig.height = 6.5}

#++++++++++++++++++++++++++++++++++++++++++++++++++++++#
# Read create tree based on Open Tree of Life taxonomy
#++++++++++++++++++++++++++++++++++++++++++++++++++++++#

# # matching names from open tree taxonomy
# taxa <- tnrs_match_names(
#   names = levels(dat$sp1.name) %>%
#     str_replace_all("_", " "),
#   context_name = "Animals"
#   )
# 
# # Create tree
# tree <- tol_induced_subtree(ott_ids = taxa$ott_id)
# tree$tip.label %<>%
#   strip_ott_ids # remove OTT IDs from tip labels
# # randomly solve non-binary phylogeny
# set.seed(6)
# bin.tree <- multi2di(tree, random = T)
# print("Randomly solved phylogeny")
# 
# # Indicate mismatch between tip labels & dataset species names
# setdiff(levels(as.factor(bin.tree$tip.label)), levels(dat$sp1.name))
# setdiff(levels(dat$sp1.name), levels(as.factor(bin.tree$tip.label)))
# # Fix names of tip labels
# bin.tree$tip.label %<>% str_replace_all("Dryophytes", "Hyla")
# 
# write.tree(bin.tree, file= "../data/phylo.novelty.tre")

#++++++++++++++++++++++++++++++++++#
# Phylogenetic tree for mcmcglmm 
#++++++++++++++++++++++++++++++++++#

# compute branch lengths of tree
phylo_branch <- read.tree(file = "../data/phylo.novelty.tre") %>%
  compute.brlen(method = "Grafen", power = 1)
plot.phylo(phylo_branch, cex = 0.7)

# saving phylogeneic matrix
phylo_cor <- vcv(phylo_branch, cor = T)

# generating inverse phylogenetic matrix for MCMCglmm
phylo_branch$node.label <- NULL
phylo_MCMC <- MCMCglmm::inverseA(phylo_branch, nodes = "ALL", scale = TRUE)$Ainv

```
<br>
Phylogenetic tree used. Tree was created for <i>sp1</i>, which was ordered alphabetically (*sp1* comes earlier than *sp2*) irrespective of the trait size and variability.

<div style="margin-bottom:70px;">
</div>


## Phylogenetic ordinal (probit) regression
Here we ask if phenotypic novelty associate with relative variability levels. We conducted ordinal regression, employing categorical ordered variability levels (smaller < intermediate < larger, see above) as response variable, and categorical trait mean novelty levels (fixed effect `mean.novelty` with 2 levels: `Novel` vs `Nonnovel`) as moderator variable, using `MCMCglmm` function. 
The model included following Random effects estimates: 

* `Study.ID`: Primary studies

* `sp1.name`: Phylogeny of parental species

* `Cross.ID`: Parental strain used in the crossing. Discriminate intraspecific populations

* `cross`: Crossing direction

* `SE.units`: Sampling variance of effect size

```{r}

# prior1<-list(
#   B=list(
#     mu=c(0,0),
#     V=gelman.prior(~mean.novelty, data=select(dat, -trait), scale=sqrt(1+1))
#     ),
#   R=list(V=1,fix=1),
#   G = list(
#     G1 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#     G2 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#     G3 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#     G3 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000),
#     G4 = list(V = 1, nu = 1, alpha.mu = 0, alpha.V = 1000)
#     )
#   )
# 
# phylmix <-MCMCglmm(
#   fixed = relative.var ~ mean.novelty,
#   family = "ordinal",
#   random = ~ Study.ID + Cross.ID + sp1.name + cross + ES.ID,
#   verbose = FALSE,
#   prior = prior1,
#   ginverse = list(sp1.name = phylo_MCMC),
#   data = select(dat, -trait),
#   nitt = 60000,  # Increase the number of iterations, default is 13000
#   burnin = 5000  # Increase the number of burnin, default is 3000
#   )
# 
# ### Save model ###
# saveRDS(phylmix, file = "../Analysis/novelty.mean.var.obj")

### Load model ###
phylmix <- readRDS("../Analysis/novelty.mean.var.obj")

#+++++++++++++++++++++++++++#
# Fixed effects output 
#+++++++++++++++++++++++++++#
get_fixed.MCMCglmm(summary(phylmix)$solutions) %>%
  dplyr::select("Factors", "Estimates", "95% credible interval", "P", "Description") %>%
  kable("html", digits = 3, caption = "Fixed effects estimates") %>% 
  kable_styling("striped", position = "left")

#+++++++++++++++++++++++++++#
# Random effects output 
#+++++++++++++++++++++++++++#
# transformation for varaince
get_random.MCMCglmm(summary(phylmix$VCV/(1+c2))) %>%
  kable("html", digits = 2, caption = "Random effects estimates") %>% 
  kable_styling("striped", position = "left")

```

The phenotypic novelty (`mean.noveltyNovel`) influenced positively. This indicates that, compared to non-novel phenotypes, novel phenotypes have greater chances to be more variable than parents' phenotypes. 


<div style="margin-bottom:180px;">
</div>

# Trait mosaicism

F1 hybrids can be seen as “a mosaic of both parental and intermediate morphological characters rather than just intermediate ones" [Rieseberg and Ellstrand 1993](https://doi.org/10.1080/07352689309701902). That is, F1 hybrid individuals often consist of trats closely resemble one parent, intermediate, and resemble the other parent. Mosaicism indicates trait integration of parents are often collapse in F1 hybrids. Here we investigate the strength of trait mosaicism in male mating traits.

<div style="margin-bottom:70px;">
</div>

## d<sub>mismatch</sub> calculation

To quantify trait mosaicism in each crossing, we calculated d<sub>mismatch</sub>  following [Thompson et al. 2019](https://www.biorxiv.org/content/10.1101/818658v1.full#disp-formula-1). d<sub>mismatch</sub> was calculated as follows:

$d_{mismatch} = \sqrt{2} * \sqrt{ Z_i^2 + Z_j^2 - \frac{Z_i + Z_j}{\sqrt{2}}^2 }$
<br>
Where $Z_i$, standardized hybrid trait value in trait $i$, is <br>
$Z_i = \frac{hyb_i - spSS_i}{spLL_i - spSS_i}$ <br>

$Z_i$ is 0-1 if F1 phenotypic mean lies within the range of parents. We note, however, novel phenotype expression (transgressive segregation) can result in quite large $Z_i$: when trait size is large and parental phenotypic divergence is small, novel hybrid phenotype will result in quite large $Z_i$. This seems occurred in mice (see bellow) <br>

```{r}

dat <- original.dat %>%
  select(Study.ID, Cross.ID, taxa, Genus, Reciprocal, contains("Mn")) %>%
  # Gather reciprocal hybrid data
  gather(
    key = Hybrid, value = Mn.hybrid, 
    -c(Study.ID, Cross.ID, taxa, Genus, Reciprocal), -contains("Mn.sp")
    ) %>%
  drop_na(Mn.hybrid) %>%
  # Calculate standardized hybrid phenotype mean
  mutate(
    Dominance = ifelse(
      Mn.sp1 > Mn.sp2, 
      (Mn.hybrid - Mn.sp2)/abs(Mn.sp1 - Mn.sp2),
      (Mn.hybrid - Mn.sp1)/abs(Mn.sp1 - Mn.sp2)
    )
  ) %>%
  mutate_at("Cross.ID", as.factor) %>%
  arrange(taxa, Genus, Cross.ID, Hybrid) %>%
  # only get crosses with > 2 traits
  # Reciprocal hybrids are separated
  group_by(Cross.ID, Hybrid, taxa, Genus, Study.ID, Reciprocal) %>%
  filter(n() > 2) %>%
  # Create all combinations of standardized hybrid phenotype mean
  do(data.frame(t(combn(.$Dominance, 2)))) %>%
  # Calculate dominance mismatch
  mutate(
    Mismatch = sqrt(2) * sqrt( X1^2 + X2^2 - ( (X1 + X2) / sqrt(2) )^2 ),
    Mismatch.log = log(Mismatch)
  ) %>%
  left_join(meta) %>%
  mutate_if(is.character, as.factor) %>%
  within(taxa <- ordered(taxa, levels = c("Neuroptera", "Coleoptera", "Diptera", "Lepidoptera", "Orthoptera", "Aves", "Rodentia", "Anura", "Cichliformes"))) %>%
  as.data.frame

```
<div style="margin-bottom:70px;">
</div>

## Distribution of d<sub>mismatch</sub> 

```{r}

dat %>% 
  summarise(
    'Trait combination' = length(X1),
    'Species pair' = length(unique(species.pair)),
    'Crossing' = length(unique(Cross.ID))
    ) %>% 
  kable("html", caption = "Dataset summary") %>% 
  kable_styling("striped", position = "left")

ggplot(data = dat, aes(x = Cross.ID, y = Mismatch)) +
  geom_point(alpha = 0.4, aes(color = Hybrid)) +
  xlab("Cross ID") + ylab("dmismatch") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_grid(~taxa, scales = "free") +
  ggtitle("All dmismatch values across orders")

ggplot(
  data = dat %>%
    filter(!grepl("musculus", Cross.ID)), 
  aes(x = Cross.ID, y = Mismatch)) +
  xlab("Cross ID") + ylab("dmismatch") +
  geom_point(alpha = 0.4, aes(color = Hybrid)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_grid(~taxa, scales = "free") +
  ggtitle("dmismatch across orders excluding Rodentia")

```
d<sub>mismatch</sub> is quite large in crossing involving mices (Rodentia), due to large trait value.

<div style="margin-bottom:70px;">
</div>

## General strength of d<sub>mismatch</sub> 

Estimated mean d<sub>mismatch</sub> across all studies by phylogenetic random model (using `MCMCglmm` function).<br>

The model included following Random effects estimates: 

* `Study.ID`: Primary studies

* `sp1.name`: Phylogeny of parental species

* `Cross.ID`: Parental strain used in the crossing. Discriminate intraspecific populations

* `Hybrid`: Crossing direction

* `SE.units`: Sampling variance of effect size

```{r}

#++++++++++++++++++++++++++++++++++#
print("Phylogenetic tree for mcmcglmm")
#++++++++++++++++++++++++++++++++++#

# compute branch lengths of tree
phylo_branch <- read.tree(file = "../data/phylo.novelty.tre") %>%
  compute.brlen(method = "Grafen", power = 1)
plot.phylo(phylo_branch, cex = 0.7)

# # saving phylogeneic matrix
# phylo_cor <- vcv(phylo_branch, cor = T)
# 
# # generating inverse phylogenetic matrix for MCMCglmm
# phylo_branch$node.label <- NULL
# phylo_MCMC <- MCMCglmm::inverseA(phylo_branch, nodes = "ALL", scale = TRUE)$Ainv

# phylmix <-MCMCglmm(
#   fixed = Mismatch ~  1,
#   # idh(SE):units | weight by SE of effect size
#   random = ~ Study.ID + sp1.name + Cross.ID + Hybrid,
#   verbose = FALSE,
#   ginverse = list(sp1.name = phylo_MCMC),
#   nitt = 60000,  # Increase the number of iterations, default is 13000
#   burnin = 5000,  # Increase the number of burnin, default is 3000
#   data = dat
# )
# saveRDS(phylmix, file = "../Analysis/mismatch.obj")

phylmix <- readRDS("../Analysis/mismatch.obj")

#+++++++++++++++++++++++++++#
# Fixed effects output 
#+++++++++++++++++++++++++++#
get_fixed.MCMCglmm(summary(phylmix)$solutions) %>%
  dplyr::select("Factors", "Estimates", "95% credible interval", "P", "Description") %>%
  kable("html", digits = 3, caption = "Fixed effects estimates") %>% 
  kable_styling("striped", position = "left")

#+++++++++++++++++++++++++++#
# Random effects output 
#+++++++++++++++++++++++++++#
# transformation for varaince
get_random.MCMCglmm(summary(phylmix$VCV)) %>%
  kable("html", digits = 2, caption = "Random effects estimates") %>% 
  kable_styling("striped", position = "left")

```
Even data included quite large d<sub>mismatch</sub>, overall it did not differ from 0. Yet, the estimate (β  = 4.41, CI = -3.05 – 10.29) is still much larger than  previously reported mean d<sub>mismatch</sub> 0.6 [Thompson et al. 2019](https://www.biorxiv.org/content/10.1101/818658v1.full#disp-formula-1). This is presumably because novel phenotype expression, which should increase d<sub>mismatch</sub>, is much more frequent in our data compared to [Thompson et al. 2019](https://www.biorxiv.org/content/10.1101/818658v1.full#disp-formula-1).

<div style="margin-bottom:70px;">
</div>

## Factors affect d<sub>mismatch</sub>

We asked if any species-level moderators (Genetic divergence between parents, `Genet.divergence`; Viability of reciprocal cross, `Reciprocal`; Heterogametic sex, `Hetero.sex`; Parents' distribution overlap, `Distribution`) influence d<sub>mismatch</sub> values by phylogenetic random model. Random effects were identical as [above] (## General pattern of mismatch d<sub>mismatch</sub>).
```{r}

dat3 <- dat %>%
  drop_na(Genet.divergence, Reciprocal, Hetero.sex, Distribution)

# phylmix <-MCMCglmm(
#   fixed = Mismatch ~  Genet.divergence + Reciprocal + Hetero.sex + Distribution,
#   # idh(SE):units | weight by SE of effect size
#   random = ~ Study.ID + sp1.name + Cross.ID + Hybrid,
#   verbose = FALSE,
#   ginverse = list(sp1.name = phylo_MCMC),
#   nitt = 60000,  # Increase the number of iterations, default is 13000
#   burnin = 5000,  # Increase the number of burnin, default is 3000
#   data = dat3
# )
# saveRDS(phylmix, file = "../Analysis/mismatch.reg.obj")

phylmix <- readRDS("../Analysis/mismatch.reg.obj")

#+++++++++++++++++++++++++++#
# Fixed effects output 
#+++++++++++++++++++++++++++#
get_fixed.MCMCglmm(summary(phylmix)$solutions)  %>%
  dplyr::select("Factors", "Estimates", "95% credible interval", "P", "Description") %>%
  kable("html", digits = 3, caption = "Fixed effects estimates") %>% 
  kable_styling("striped", position = "left")

#+++++++++++++++++++++++++++#
# Random effects output 
#+++++++++++++++++++++++++++#
# transformation for varaince
get_random.MCMCglmm(summary(phylmix$VCV)) %>%
    kable("html", digits = 2, caption = "Random effects estimates") %>% 
    kable_styling("striped", position = "left")

```
None of species level moderators did not influence d<sub>mismatch</sub>, as [Thompson et al. 2019](https://www.biorxiv.org/content/10.1101/818658v1.full#disp-formula-1) showed. 


<div style="margin-bottom:180px;">
</div>
# Session information
```{r}
sessionInfo()  # show R version etc
```

